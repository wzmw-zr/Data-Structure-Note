#  栈

## 一、栈的结构定义

```c++
typedef struct stack {
    typename *elements;
    int size, top;//top是栈顶
} Stack;
```



## 二、栈的结构操作

### 1.入栈

栈顶指针向上移动一位(不可越界)，然后放入元素，就是入栈操作。

```c++
int push(Stack *s, int val) {
    if (s == NULL) return 0;
    if (s->top + 1 == s->size) if (!expand(s)) return 0;
    s->data[++(s->top)] = val;
    return 1;
}
```



### 2.出栈

栈顶指针向下移动一位就是出栈操作。

```c++
int pop(Stack *s) {
    if (!s) return 0;
    if (empty(s)) return 0;
    s->top -= 1;
    return 1;
}
```



### 3.获取栈顶元素

在合法的情况下，通过栈顶指针就可以直接获取栈顶元素。

```c++
int top(Stack *s) {
    return s->data[s->top];
}
```



### 4.栈的判空

只需判断栈顶指针是否为-1。

```c++
int empty(Stack *s) {
    return s->top == -1;
}
```



## 三、关于栈的应用

### 1.括号匹配

> 当问题的规模较大时，将大问题转化为小规模的问题。

栈的思想：将一次括号匹配(即一对括号)作为一个完整的事件，那么左括号是事件开端，右括号是事件结束。这样就对应着栈的入栈和出栈。

那么+1就相当于进，-1相当于出，这也是一个完整的事件。

实际上括号匹配可以看作是事件与事件之间的完全包含关系。

这种思想也可以用在树的结构中，树的结构可以看作是父节点包含了字节点，这样也是完全包含关系。因此可以使用栈来进行树的遍历。

**栈适合用来处理具有完全包含关系的问题。**

### 2.关于系统栈的思考

函数调用使用的就是系统栈，只要是栈可以解决的问题，就可以使用系统栈来解决，而使用系统栈的最多情况就是递归程序。

那么可以得出这样的结论，凡是使用栈可以解决的问题都是可以使用递归(使用系统栈)，凡是使用递归解决的问题都是可以使用栈解决。

> 核心已转储：在爆栈时会保存这个程序的一些核心信息到一个被称为cal文件里，可以方便我们纠错。

### 3.栈的一些应用场合

栈在后面可以应用于树的深度遍历和图的深度优先搜索。

队列(循环)后面可以应用于树的层序遍历和图的广度优先搜索。

> 遇到了在编译器实现上的问题，在manjaro系统下的gcc与g++在printf函数中如果调用其他函数，则是从右到左执行的，所以有时候会造成部分数据与其他人的不一样。

