# 单调队列

##  一、单调队列的定义

**单调队列**即元素单调递增或者单调递减的队列。通常用来**解决$RMQ$问题，即区间最大(小)值查询问题(Range Maximum(Minimum) Query)。**即单调队列可以维护区间最值。



## 二、单调队列性质

1. 单调队列中元素是单调的。
2. 队首元素是区间的全局最值，之后**单调队列中每一个元素都是上一个元素之后的区间的最值**。
3. 单调队列的操作也是队尾进元素，队首出元素(**队尾进元素就需要调整单调队列使其重新满足单调性**)。
4. **单调队列可以维护区间最值**。==**单调递增队列可以维护区间最小值，单调递减队列可以维护区间最大值。**==



## 三、单调队列能够维护区间最值的证明

假设当前的单调队列维护的是区间$[i,j]$的最值，在还没有处理完区间内的所有元素之前，下标为$q$的元素从单调队列尾部进入单调队列，将前面破坏了单调队列单调性的元素删除，在下标为$p$的元素后停下来。

在这里首先可以确定**下标为$q$的元素是下标在$(p,q$]区间中的元素的最值。**

(1)在下标为$p$的元素失效出队列之前，下标为$p$的元素是$[p,q]$区间的最值;

(2)在下标$p$的元素因为失效出队列后，直到下标为$q$的元素出队之前，下标为$q$的元素一直都是$(p,q]$的最值;而那些下标在$(p,q)$之间的元素如果还有元素没有失效，此时的区间最值是下标为$q$的元素(哪怕下标为q的元素有被替换，新的元素也必定满足这种性质。);

(3)而当下标为$q$的元素即将出队时，$(p,q)$之间的元素都已经失效了。

如此，可以证明单调队列能够维护区间最值。(即便有新元素淘汰了下标为 $p,q$的元素，这个新元素必然符合这些证明过程)。



## 四、单调队列的结构定义

单调队列的结构定义和队列的结构定义一样。我们可以使用结构体，完成基本的操作，也可以使用更为简单的方式，不过我还是倾向于前者。

**单调队列存储的一般就是数组下标。** ==**这是一个编程技巧，我们能存坐标的时候尽量不存值。**==因为我们可以通过下标获取到值，但是我们不能由值获取到下标。



## 五、单调队列的结构操作

### 1.元素队尾入队

元素在队尾入队可能会破坏单调队列的单调性，那么就**先将新元素不断和队尾元素比较，==如果会破坏单调性就删除队尾元素，直到：（1）队列为空，或者（2）单调性能够维持。==**



### 2.队首元素出队

**单调队列队首元素会在队首元素失效时出队，在此之前需要先判断队首元素是否失效。**



**代码如下：**

```c++
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<ctime>
using namespace std;
#define MAX_N 100000

int arr[MAX_N + 5];
// 简版结构定义，单调队列存的是元素下标，这是一个技巧，能够存下标的就不存数据
int q[MAX_N + 5], head, tail;

int main() {
    int n, k;
    cin >> n >> k;
    for (int i = 0; i < n; i++) cin >> arr[i];
    for (int i = 0; i < n; i++) {
        // 队尾进元素，arr[i]是即将入队的元素
        // 若队列的单调性会遭到破坏，不断删除现在单调队列队尾的元素直至单调性能够在arr[i]入队后依旧保持
        // 单调性调整停止的条件有两个：
        //（1）单调队列为空
        //（2）找到能够继续维护单调性的位置
        while (tail - head && arr[i] < arr[tail - 1]) tail--;
        // 队尾入元素
        q[tail++] = i;
        // 队首元素失效时处理
        // 如果队首元素还没有失效，继续
        if (i + 1 < k) continue;
        // 当当前单调队列达到了区间范围限制，队首元素失效，队首元素出队
        if (i - q[head] == k) head++;
        i + 1 == k || cout << " ";
        cout << arr[q[head]];
    }
    return 0;
}
```





