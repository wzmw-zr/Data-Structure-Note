# 堆与优先队列

我们**可以使用set来模拟堆，set可以直接模拟小顶堆，但是对于大顶堆，取个负号即可。**

```c++
class KthLargest {
public:
    // 对于允许重复数字的，我们需要定义一个新的结构，来保证相同数字不重
    typedef pair<int, int> PII;
    set<PII> s;
    int k, t;
    KthLargest(int k, vector<int>& nums) {
        this->t = 0;
        this->k = k;
        for (int i = 0; i < nums.size(); i++) {
            add(nums[i]);
        }
        return ;
    }
    
    int add(int val) {
        if (s.size() < k) {
            s.insert(PII(val, t++));
        }
        else if (val > s.begin()->first) {
            s.erase(s.begin());
            s.insert(PII(val, t++));
        }
        return s.begin()->first;
    }
};
```

另外，**对顶堆可以维护某一比例的数字，这需要大顶堆和小顶堆。**



## 一、堆的基础知识

堆可以看作一棵完全二叉树，具有$N$个元素，高度为$O(\log{N})$。由于完全二叉树可以使用数组来存储，所以，堆也可以使用数组来存储。

### 1.堆的类型

堆有两种类型：

（1）大根堆：根节点权值大于等于树中节点权值的堆。

（2）小根堆：根节点权值小于等于树中节点权值的堆。

> 由于堆可以看作是特殊的树，所以当完全二叉树看待，左子树和右子树的根节点也要满足相应的性质。

### 2.堆操作的时间复杂度

由于堆是完全二叉树，堆的**插入，删除操作的时间复杂度为：$O(\log{N})$，**即这棵完全二叉树的高度。

堆具有的一个重要性质：堆序性。即堆中每个节点的权值都大于等于（或者小于等于）其子树任意节点的权值。

为了维护堆的堆序性，在修改堆中节点时会对堆进行调整，**调整的时间复杂度为$O(\log{N})$**。堆的调整方式有两种，自下而上的调整和自上而下的调整，即上滤和下滤。

> ==**堆的尾部插入和头部弹出操作都需要对堆进行调整，尾部插入是自下而上调整，头部弹出是自上而下调整。**==

### 3.关于堆与完全二叉树的关系

堆的结构实际上就是完全二叉树，而完全二叉树的下标我们有两种使用方式：（1）从1开始 （2）从0开始。

#### (1)从1开始

下标为ind的节点如果有左右孩子，那么左右孩子的下标为2 * ind, 2 * ind + 1。

下标为ind的节点如果不是根节点，那么其父节点的下标为ind / 2

#### (2)从0开始

下标为ind的节点如果有左右孩子，那么左右孩子的下标为2 * ind  + 1, 2 * ind + 2。

下标为ind的节点如果不是根节点，那么其父节点的下标为(ind - 1) / 2

> 数据结构的另一种理解：**==定义一种性质，然后定义一系列操作去维护这种性质==**



## 二、堆的结构定义

堆的结构定义如下，类似于完全二叉树：

```c++
typedef struct priority_queue { 
    int *data;
    int cnt, size;
} priority_queue;
```



## 三、堆的结构操作

> 在初始化堆时，申请的连续空间需要大一点，因为这也是和完全二叉树一样，都是从下标1开始存储数据。

**注意：堆顶元素的位置的下标是1,即通过data[1]访问的是堆顶元素，而0下标是不使用的。**

### 1.堆的插入(尾部插入)

在向堆中插入元素时，我们会先将新的元素插入到堆的最后，即数组的末尾，之后再调整它额位置来维护堆的堆序性。

**堆的插入，即尾部插入之后的调整是自下而上的调整。调整的循环终止条件为：(1)到达根节点(2)当前节点的父节点优先级更高。**

堆的插入操作的算法流程：

```
1. 把新元素保存在数组的最后。
2. 找到新插入元素的父节点位置。
3. 将新元素与父节点比较大小。
4. 若新插入的元素与其父节点大小不符合堆序性则交换它和父节点的位置，并回到步骤 2；若符合则插入操作完成。
```

实际的实现代码：

```c++
int push(priority_queue *q, int val) {
    if (q->cnt == q->size) return 0;
    q->data[++q->cnt] = val;
    int ind = q->cnt;
    // 注意循环终止条件
    while (ind >> 1 && q->data[ind] > q->data[ind >> 1]) {
        swap(&q->data[ind], &q->data[ind >> 1]);
        ind >>= 1;
    }
    return 1;
}
```

由于我们使用了一个数组来保存堆的所有元素，因此在遍历输出堆的时候，只要从下标0到$size-1$循环输出数组中的所有元素就行。

尾部插入的一次调整时间复杂度为$O(\log{N})$，而最后一层实际上数量最多是$O(\frac{N}{2})$，那么就可以直接得出这种建堆方法的时间复杂度为$O(N\log{N})$。

### 2.堆顶元素的删除(头部弹出)

**堆顶元素的删除，即头部弹出操作之后的调整是自上而下的调整。**

删除堆顶元素的算法流程：

```c++
// 将堆顶元素与最后一个元素互换，最终结果就是将堆在缩小的同时，后面的部分是有序的
// 这样就不需要使用额外的存储空间
1. 将堆顶元素和最后一个元素交换。
2. 删除堆的最后一个元素。
3. 自顶向下调整元素的位置，使之满足堆序性。
```

**注意向下调整的循环终止条件：(1)当前节点没有子节点(2)当前节点的孩子节点的优先级比当前节点低，换句话说就是没能继续向下推进。**

实际的实现代码：

```c++
int pop(priority_queue *q) {
    if (empty(q)) return 0;
    swap(&q->data[1], &q->data[q->cnt--]);
    int ind = 1;
    while ((ind << 1) <= q->cnt) {
        // 关于位运算的使用！！！
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if (q->data[l] > q->data[temp]) temp = l;
        // 在进行下标扩大操作时，需要时刻注意下标是否超过了范围！！！
        if (r <= q->cnt && q->data[r] > q->data[temp]) temp = r;
        // 终止条件：下表没有发生变化
        if (temp == ind) break;
        swap(&q->data[ind], &q->data[temp]);
        ind = temp;
    }
    return 1;
}
```

这里我们采用的是普通的首尾交换，但是在需要动态维护的堆中我们是不能首尾交换的，而是用最后一个元素覆盖第一个元素。

### 3.堆排序算法的实现

堆排序算法实际上是在经过堆的插入与删除操作之后在原来的空间中获得排好序的数据。

> 大顶堆在排序算法之后，空间存的是自小到大的数据;小顶堆在排序算法后，空间中村的是自大到小的数据。



## 四、堆和优先队列

堆就是优先队列。

| 普通队列 | (最大/最小)堆(优先队列)          |
| -------- | -------------------------------- |
| 尾部入队 | 尾部插入                         |
| 头部出队 | 头部弹出                         |
| 先进先出 | 每次出队权值(最大/最小)的元素    |
| 数组实现 | 数组实现，逻辑上看作堆(优先队列) |



##  五、线性建堆法(自上而下调整)

在堆排序中，时间复杂度是$O(N\log{N})$,原先在建堆时，是自下而上维护堆的性质，这样建堆的时间复杂度就是$O(N\log{N})$。而在堆顶弹出元素来使得数据有序时，需要的时间复杂度一定是$O(N\log{N})$,所以可以考虑减少建堆的时间复杂度。

原本建堆的时间复杂度是$O(N\log{N})$,此时我们采用的是自下而上的建堆方法，**更恰当的理解是线性建堆的过程实际上也是一个具有完全包含关系的问题，但是这个完全包含问题我们不是采用递归的方式，我们是直接从倒数第二层开始向上，逐层完成以当前节点作为根节点的堆的向下的调整，==一棵树的根节点要调整的次数最多就是这棵树的高度-1。==**

线性建堆法的证明： 

由于最后一层是不需要调整的，从倒数第二层开始，这层的节点最多需要调整一次，之后逐层向上，每上一层，这层节点最多需要调整的次数就会加1，那么我们就可以获得总的时间复杂度公式，假设这个堆的层数为n：
$$
\begin{aligned}
T(n)&=1*2^{n-2}+2*2^{n-3}+3*2^{n-4}+...+(n-1)*2^0\\
&=2^n-n
\end{aligned}
$$
由于层数为n的堆的节点个数在$[2^{n-1},2^n-1]$之间，所以在总的节点个数为N的情况下，相当于，$T(N) = O(N)$，这就是线性的建堆时间。

**但是线性建堆法也有相应的缺陷：==线性建堆法不适合需要动态建堆的情况，线性建堆法适用于堆中元素已经确定下来的情况。==**

线性建堆的代码如下：

```c++
// 这是自上向下调整堆，实际上要注意的就是自己定义的参数
void downUpdate(int *arr, int n, int ind) {
    while ((ind << 1) <= n) {
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if (l <= n && arr[temp] < arr[l]) temp = l;
        if (r <= n && arr[temp] < arr[r]) temp = r;
        if (temp == ind) break;
        swap(arr[temp], arr[ind]);
        ind = temp;
    }
}
//线性建堆
void build(int *arr, int n) {
    for (int i = n >> 1; i >= 1; i--) downUpdate(arr, n, i);
} 
// 堆排序
void heap_sort(int *arr,int n) {
    arr--;
    build(arr, n);
    for (int i = n; i > 1; i--) {
        swap(arr[1], arr[i]);
        downUpdate(arr, i - 1, 1);
    }
}
```



## 六、堆与优先队列的用途

优先队列有着将权值优先的元素率先出队的功能，所以优先队列可以用于解决哈夫曼编码问题。

此外由于优先队列涉及到了优先级的概念，所以优先队列可以用于系统的任务调度问题上。



## 七、堆与优先队列编码中的易错点

### 1.判空操作注意一下前面需不需要取反

### 2.堆尾插入和堆首弹出之后的调整需要注意循环终止条件

### 3.位运算中需要注意左移代表乘2,右移代表除2



## 八、堆与优先队列的特性与应用

### 1.获取优先级最高的元素

这个实际上就是堆的基础操作的使用。

### 2.进行堆排序

也是堆的基础操作的使用，另外虽然堆排序的时间复杂度也是$O(n\log{n})$，但是还是没有归并快。

### 3.堆与优先队列的补充性质

（1）虽然堆只有大顶堆和小顶堆两种，但是我们都是可以将这看作选择优先级最高的。

（2）令堆的元素数量为n，在大顶堆中，堆顶元素是最大的;在小顶堆中，堆顶元素是第n大的元素(也就是最小的元素)。

### 4.处理数据流

#### (1)获取前k优先级\\第k优先级的元素(==top k问题==)

**正常的排序算法只能处理给定了的一堆序列，无法进行动态更新。并且当数据量非常大的时候进行排序的时间复杂度也是非常大的。**

根据上面的性质，**堆是可以用来对数据流进行处理，而且我们可以通过对堆大小的设定，来实现不同的功能。**

以大小为k的小顶堆为例，可以每次根据堆顶元素和新元素比较大小决定是否更新，这样我们就可以获得数据流的前k大的元素(第k大的元素);这只需要我们合理利用堆的性质。

同理使用大顶堆我们可以获得数据流的前k小元素(第k小元素)，而且堆是可以动态更新的。

**在进行前k优先级元素的获取的时候，我们使用堆可以有效地节省空间**，只需要$O(k)$的空间，同时时间复杂度也限定在了$O(n\log{k})$级别，可以看作是线性级别，而正常的排序算法需要$O(n\log{n})$时间复杂度，并且堆是可以动态更新的。

==解决top k问题，使用堆的空间复杂度为$O(k)$级别，因此处理数据流是很适合的。==

#### (2)获取==数据流的中位数==

获取数据流的中位数也是使用堆，但是需要使用两个堆，一个大顶堆保存小一半的数据，一个小顶堆保存大一半的数据。**中位数这种==涉及到比例的问题是必须使用$O(n)$的空间来保存数据==，因为中位数是和所有数据相关的。**

以此类推，可以通过调整两个堆的大小比例，可以求出其他比例的数据。

### 5.处理多数据流

堆适合用来处理多数据流**，使用堆时多数据流中的每个数据只需要处理一次，**但是使用其他一些排序算法的话，即使是归并排序，同一元素也会被处理多次。



## 九、关于堆与优先队列中一些问题的思考与收获

### 1.关于结构体的直接赋值问题

在c语言中，==**结构体是可以直接赋值的。**==这样就可以省去一些情况下使用结构体指针不方便的情形,以及，由于结构体可以直接赋值，可以节省大量的空间。

既然结构体是可以赋值的，那么我们就可以避免结使用结构体指针的一个弊端：所有对结构体的修改都是会改变到原来的结构体上。

但是更多时候我们还是先使用结构体指针来试一下水再说。



### 2.关于堆的完全包含关系性质

由于堆实际上可以看作是一个完全二叉树，而树也是有完全包含关系的，所以我们可以考虑在一些情况下使用这种性质，比如**自上而下调整堆的时候，可以采用递归的方式实现**。

而正常情况由于完全二叉树的特殊性，可以使用循环来将递归调整为直接计算的问题。



### 3.关于堆处理的节点的优先级的思考

#### (1)将优先级比较抽取为一个函数

这是一个技巧，在很多情况下，堆排序所需要处理的节点的优先级的计算与组成是很复杂的，那么更恰当的做法是建立一个比较优先级的函数来比较两个节点的优先级。

#### (2)当节点的优先级是会随着时间变化时的处理情况(==动态优先级==)

在堆中的节点的优先级可能是静态的，确定了就不会改变，这种情况是最简单的，基本的堆操作就可以解决。

这种时候不要强行使用线性建堆法，这样到最后的时间复杂度是$O(n^2)$级别的，耗时太多。

观察是否可以将节点分成多个堆，每个堆只需要建立一次，同一堆里的节点有着某种相似的特性，（**Linux的进程优先级就是一个很好的例子**）对于多个堆的堆顶元素进行优先级比较，这样会节省很多时间。

> 另一个问题，如果所有节点的优先级都是会随时间而改变，并且无法分成多个堆时怎么处理？



### 4.关于程序运行所需内存空间问题

由于malloc出来的空间即使释放掉，也会被判题机器认定占用了空间，并且申请内存是很耗费时间的。如果希望程序运行较快，那么需要将使用malloc的部分改为直接申请，但是重复利用。



### 5.关于for循环中的一些注意点

在for循环中，其比较条件中的变量如果无特殊情况，不要改变，否则后果会比较严重。那么此时**最好的做法就是将这个会变的量作为循环变量的初值。**