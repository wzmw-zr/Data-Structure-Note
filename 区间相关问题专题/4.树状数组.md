# 树状数组

树状数组是用来维护区间信息的数据结构，适合解决单点修改、区间查询(区间求和，RMQ)问题。

> 线段树同样可以实现树状数组的功能，并且还支持区间修改，但是树状数组的代码短，尤其适合解决单点修改问题。

 

## 一、树状数组的原理

树状数组的思想：**用一个大节点表示一些小节点的信息**，进行**查询的时候只需要查询一些大节点**而不是更多的小结点。**==这里树状数组也使用了倍增思想，体现为lowbit函数。==**

![img](fenwick1.png)



使用c数组存储对a数组一定数量的数字进行管理的相关信息，从这里可以看出来，$c_2$管理$a_1,a_2$，$c_4$管理$a_1,a_2,a_3,a_4$，$c_6$管理$a_5,a_6$，$c_8$管理所有。



## 二、用法与操作

树状数组使用**==lowbit函数，用于指示c数组中某下标处元素管理a数组中数据的个数==**。

```c++
int lowbit(int x) { return x & -x ;}
```

`lowbit(x)=x & -x`这实际上是**==获得二进制表示下x最低位的1的权值，也就是$c[x]$管理的a数组中的元素的个数==**，这里体现了倍增法的思想。

那么，单点修改(同样体现倍增法思想)的操作如下：

```c++
void add(int x, int k) {
    while (x <= n) { // 单点修改，不能越界
        c[x] = c[x] + k;
        x = x + lowbit(x); // 可以证明，新的x对应的c[x]一定管理了最初的a[x]
    }
}
```

可以证明，单点修改的时间复杂度为$O(\log N)$。

对于区间查询，这里就以查询前缀和为例：

```c++
int getsum(int x) {
    int ans = 0;
    // 每次减去lowbit(x)实际上就是处理完当前c[x]所管理的a数组中的信息，处理前面的数组中的信息了
    while (x >= 1) {
        ans = ans + c[x];
        x = x - lowbit(x);
    }
    return ans;
}
```

树状数组不适合区间修改，但是可以通过逐个单点修改实现。

> 树状数组从下标1开始填数字，和前缀和，差分数组一样。



## 三、线性时间建立树状数组

因为每一个节点的值是由所有与自己直接相连的儿子的值求和(或其他操作)得到的，因此可以**每次确定完儿子的值后，用自己的值更新自己的直接父亲**。

```c++
// O(n)建立树状数组
void init() {
    for (int i = 1; i <= n; i++) {
        t[i] += a[i];
        int j = i + lowbit(i);
        if (j <= n) t[j] += t[i];
    }
}
```

