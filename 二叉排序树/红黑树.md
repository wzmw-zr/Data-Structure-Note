# 红黑树

## 一、红黑树的平衡条件

1. 每个节点非黑即红
2. 根节点是黑色
3. 叶子节点(NIL)是黑色
4. 如果一个节点是红色，那么它的两个字节点都是黑色的
5. 从跟节点出发到所有叶节点路径上，黑色节点数量相同。(**红黑树控制平衡的终极条件**)

> AVL树是通过控制树高来控制平衡条件，==红黑树的本质也是通过控制树高来控制平衡条件。==
>
> ==红黑树中最长的路径的长度最多为最短路径的2倍。==



## 二、红黑树的调整策略

1. 插入操作站在祖父节点看（在父节点看，即使失衡了也不调整）
2. 删除操作站在父节点看（只有在父节点向下看，发现失衡了才调整）
3. 插入和删除的情况处理共5种



## 三、红黑树的结构定义





## 四、红黑树的插入调整

**==红黑树的新插入节点一定是红色的==**，因为**红黑树每条路径上的黑色节点的个数是相等的，如果插入黑色节点，不管插入到哪条路径上都会造成失衡**。

**==插入过程中的失衡条件：插入节点是红色，其父节点也是红色。==**

**插入节点的失衡处理是站==在插入节点的祖父节点上来看==的**，这是因为==**需要处理叔父节点**==。

在插入失衡中，确定的三个节点的颜色，**插入节点红色，父节点红色，祖父节点黑色**，因此，**红黑树插入节点失衡的情况可以根据叔父节点的颜色分为两类：**

(1)叔父节点是红色

(2)叔父节点是黑色，此时又有四种情况：LL型，LR型，RR型，RL型。

### 1.叔父节点是红色

![深度截图_选择区域_20200304095227](/home/zr/Desktop/data structure note/二叉排序树/深度截图_选择区域_20200304095227.png)

x，父节点，叔父节点都是可以有孩子的，这里是简化的情况。

由于插入的是红色的节点，所以第五条性质是一定满足的，所以x，父节点，叔父节点都是满足第五条性质的，此时**只需要==将祖父节点改为红色，父节点和叔父节点改为黑色，红黑树的性质就可以继续维持==**。(路径上黑色节点数量不变，颜色冲突消除)

祖父节点所在子树满足了红黑树的性质，接下来就是继续向上进行调整。

从这里可以得出一个结论：红-黑-黑，黑-红-红，这两种三元组可以看作是等价的，**因为从根节点往下看，各个路径上的黑色节点数量是相同的。**

![深度截图_选择区域_20200304100303](/home/zr/Desktop/data structure note/二叉排序树/深度截图_选择区域_20200304100303.png)



### 2.叔父节点是黑色

插入节点的位置可以参考AVL树，继续分为LL型，LR型，RR型，RL型四种情况。**以LL为例，LR可以转化为LL，RR和RL方法类似。**

首先，对于RR型的如图，可以确定，经过左旋之后这个红黑树依旧可以保持红黑树的平衡性质，并且变成了LL型的。对于LL型的同理。**RR型和LL型可以通过左旋、右旋互相转化。**

**由此可以得到：左旋和右旋是不影响红黑树的平衡性质的。**

![深度截图_选择区域_20200304103019](/home/zr/Desktop/data structure note/二叉排序树/深度截图_选择区域_20200304103019.png)



### (1)LL型

![深度截图_选择区域_20200304103448](/home/zr/Desktop/data structure note/二叉排序树/深度截图_选择区域_20200304103448.png)



在LL型中，可以确定颜色的节点有，x，父节点，叔父节点，祖父节点，兄弟节点，孩子节点。**在插入操作中，从祖父节点往下看意味着最终祖父节点是需要有改变的。**

LL型的调整操作和AVL树一样，进行一个大右旋，结果如下：

![深度截图_选择区域_20200304110420](/home/zr/Desktop/data structure note/二叉排序树/深度截图_选择区域_20200304110420.png)

接下来**调整颜色，==调整的策略是让颜色是节点的每一棵子树之上的路径的黑色节点的数量和最开始之上的路径的黑色节点的数量一样==**。(**==这实际上就是维护第5条性质。==**)

![深度截图_选择区域_20200304111731](/home/zr/Desktop/data structure note/二叉排序树/深度截图_选择区域_20200304111731.png)

根据之前颜色确定的那些节点，可以得出，上面的三个节点有**两种调整颜色的方案，“黑-红-红”和“红-黑-黑”。**(所以红黑树的代码不是唯一的)

### (2)LR型

进行一个小左旋之后再进行大右旋，辅以调整即可。

### (3)RR型

一个大左旋之后调整即可。

### (4)RL型

先进行小右旋，之后进行大左旋，辅以调整即可。



## 五、红黑树的删除操作

红黑树的删除有两类大情况：(1)删除的是红色节点 (2)删除的是黑色节点。

由于**删除红色的度为0,1,2的节点不会影响红黑树的平衡**，第5条性质依旧是保持着的，所以**删除红色节点时无需调整**。



**删除的是黑色节点时也可以分为三种情况：删除的黑色节点的度为0,1,2。**

==删除黑色节点一定会破坏红黑树的平衡，需要调整==。**删除黑色的0,1度节点情况可以合并，而删除黑色的度为2的节点可以转化为删除黑色的度为1或0的节点。**

删除度为1的黑色节点会遇到两种情况：(1)孩子是红色的(2)孩子是黑色的。

**如果孩子是红色的，就将这个孩子改为黑色。**

**如果孩子是黑色的，这个孩子就会被标记为==双重黑==**。==**删除操作的调整就是为了去除双重黑。**==

==删除调整操作是从父节点往下看，去除双重黑。==



## 六、红黑树的删除调整

红黑树的删除调整是在删除之后进行的，并且删除调整是从父节点往下看，看是否有孩子是双重黑。

此时有如下情形：

### 1.双重黑节点的兄弟节点是黑色

#### (一)双重黑节点是左孩子

##### (1)兄弟节点的两个孩子节点是黑色

**解决方法：**父节点加一重黑色，兄弟节点和双重黑节点减一重黑色(兄弟节点变红)。

**目的**：**没有用到旋转操作**，并且这里==**使得双重黑能够在父节点为黑的情况下上移到父节点**==。



##### (2)兄弟节点的右孩子节点是红色(左孩子任意)[==RR类型==]

**解决方法**：先进行**大左旋**，之后将**现根节点(原兄弟节点，右孩子)的颜色变成原根节点的颜色，原根节点颜色变为黑色 (可以理解为原根节点和现根节点颜色互换)，双重黑节点减一重黑，现根节点(原兄弟节点，右孩子)右孩子(红色节点)加一重黑色。**

![深度截图_选择区域_20200304211710](/home/zr/Desktop/data structure note/二叉排序树/深度截图_选择区域_20200304211710.png)

==关于原根节点变成黑色的原因，原根节点的右孩子是原根节点右孩子的左孩子，原根节点右孩子是黑色，故其左孩子有可能是红色，也有可能是黑色，同时原根节点颜色不定，故变为黑色合理。==



##### (3)兄弟节点的左孩子节点是红色(右孩子为黑色)[==RL类型==]

解决方法：先进行**小右旋，调整节点颜色，就是交换原根节点和现根节点的颜色，转化为RR类型(==必须要修改颜色，因为小右旋之后还不是RR类型，调整后才是==)。**之后就是上面的类型了。



#### (二)双重黑节点是右孩子

##### (1)兄弟节点的孩子都是黑色

解决方法与上面情形相同。

##### (2)兄弟节点的左孩子是红色[==LL类型==]

**解决方法：进行大右旋，交换原根节点和现根节点(原兄弟节点，黑色)的颜色，双重黑节点减一重黑，现根节点的左孩子(红色节点)加一重黑色。**

#####  (3)兄弟节点的右孩子是红色[==LR类型==]

解决方法：先进行小左旋，调整颜色(**交换现根节点和原根节点的颜色**)为LL型，之后就和上面一样了。



### 2.双重黑节点的兄弟节点是红色

由于双重黑节点的兄弟节点是红色，那么父节点就确定是黑色了。

#### (一)双重黑节点是左孩子

此时局部简略图如下，要求**==展示出来的部分一定要满足红黑树的性质----每条路径上的黑色节点数量相等，并且默认省略的更小子树是满足红黑树性质并且每条路径上的黑色节点个数相等。==**

![深度截图_选择区域_20200304221449](/home/zr/Desktop/data structure note/二叉排序树/深度截图_选择区域_20200304221449.png)

**进行左旋，左旋结束之后由于平衡被破坏，交换现根节点和原根节点的颜色，这样就达到了平衡，如下图所示：**

![深度截图_选择区域_20200304222449](/home/zr/Desktop/data structure note/二叉排序树/深度截图_选择区域_20200304222449.png)

此时双重黑节点的父节点已经发生了改变，并且此时转化为了兄弟节点为黑色，且i兄弟节点左右孩子都是黑色的情况，双重黑节点减一重黑，根节点加一重黑。

#### (二)双重黑节点是右孩子

执行右旋操作，调整颜色，与接下来与上面的情况类似。



## 七、红黑树插入、删除调整操作的思考

红黑树的插入、删除调整的最终目的是使得每条路径上的黑色节点个数相同。

**然后我发现，只要是用到了旋转操作的，都会有原根节点和现根节点颜色的交换，这样是为了维护红黑树的平衡。**

**在进行插入、删除调整操作时，h最总要的是确定好在当前情况下能够确定颜色的节点。这样就可以理解好操作的细节。**