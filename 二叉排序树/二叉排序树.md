# 二叉查找树

二叉查找树的用途：解决与排名相关的检索需求。

**==二叉查找树只是一类具有特殊性质的树，其操作也是具有完全包含关系的问题。==**

## 一、二叉查找树的定义与性质

二叉查找树又叫二叉搜索树。

二叉查找树的性质：对于任意节点，其左子树上所有节点的值小于该节点的值，其右子树上所有节点的值大于该节点的值。



## 二、二叉搜索树的结构定义

二叉搜索树的结构定义就是正常二叉树的结构定义，不同的就是二叉搜索树特有的性质与操作。

```c++
typedef struct Node {
    int key;
    struct Node *lchild, *rchild;
} Node;
```



## 三、二叉搜索树的结构操作

### 1.二叉搜索树的插入

链表可以看作是二叉树的一种特殊情况，而**链表在插入(头插法)时需要返回节点指针，所以我们在==二叉树，二叉查找树等进行插入操作时也是返回节点指针，这是为了防止丢失节点==。**

**二叉查找树的插入操作也是一个具有完全包含关系的问题。**

**一定要注意插入时可能会有重复值被插入！！！要判断结点值是否等于插入值！！！**

```c++
Node *insert(Node *root, int key) {
    //二叉树和二叉搜索树等树结构在插入操作返回节点指针，这实际上也是为了与跟节点为空时的操作统一！！！
    if (!root) return getNewNode(key);
    // 一定要注意插入的可能是重复值，一定要判断节点值是否等于插入值，如果等于则直接返回当前节点的值
    if (root->key == key) return root;
    if (key < root->key) root->lchild = insert(root->lchild, key);
    else root->rchild = insert(root->rchild, key);
    return root;
}
```



### 2.二叉搜索树的删除(有3种情况)

**==二叉查找树的删除也是一个具有完全包含性质的问题==。二叉查找树的删除也是需要返回节点指针的，这是因为二叉查找树在删除操作之后树的结构发生了改变，需要返回根节点指针更新信息。**

二叉搜索树删除节点的3种情况：（1）删除叶子节点（2）删除度为1的节点（3）删除度为2的节点。

#### (1)删除叶子节点

**直接删除。**

#### (2)删除度为1的节点

**删除度为1的节点，将这个节点的孩子接到待删除节点的父亲节点上**，待删除节点就可以直接删除了，待删除节点在父节点的那棵子树就连接到那棵子树上。

#### (3)删除度为2的节点(==可以转化为度为0或1的情况处理==)

度为2的节点就不能直接删除待删除节点了。

**找到度为2的节点的==中序遍历前驱节点后者后继节点==来替代它。==前驱节点在左子树的最右节点，后继节点在右子树的最左节点(因为二叉查找树是按咋好中序遍历来理解的，这样是从小到大的顺序)。==**

**对于这个前驱或者后继而言，肯定不是度为2的，只会是度为1或者0的节点，那么就相当于转换为删除度为1或者度为0的节点的问题。**

二叉查找树的删除代码如下：

```c++
//在待删除节点度为2时，我们通常是选择其中序遍历的前驱或者后继来代替这个待删除节点
//然后我们去删除这个前驱或者后继
//中序遍历的前驱在是当前节点的左子树的最右节点，根据线索化章节的知识，寻找前去或者后继只需要循环就行
Node *predecessor(Node *root) {
    Node *temp = root->lchild;
    while (temp->rchild) temp = temp->rchild;
    return temp;
}

//这是寻找节点的中序遍历后继节点
Node *postdecessor(Node *root) {
    Node *temp = root->right;
    while (temp->left) temp = temp->left;
    return temp;
}

Node *erase(Node *root, int key) {
    if (!root) return root;
    if (key < root->key) root->lchild = erase(root->lchild, key);
    else if (key > root->key) root->rchild = erase(root->rchild, key);
    else {
        // 待删除节点度为0或者为1的情况，可以合并为一个操作
        if (!root->lchild || !root->rchild) {
            // 如果待删除节点度为1：有两种情况：
            //（1）左子树不为空，那么我们将左子树接回去就行
            //（2）左子树为空，那么及将右子树接回去
            // 如果待删除节点度为0：
            // 当前节点的左右孩子都为空，在下面不管怎样都应当是返回NULL，所以
            // 度为0和度为1的待删除节点的情况可以统一
            Node *temp = root->lchild ? root->lchild : root->rchild;
            free(root);
            return temp;
        } else {
            //度为2的待删除节点，这里是找到其中序遍历前驱，用前驱数据覆盖待删除节点，之后去左子树删除前驱
            Node *temp = predecessor(root);
            root->key = temp->key;
            //去左子树删除前驱
            root->lchild = erase(root->lchild, temp->key);
        }
    }
    return root;
}
```



## 四、关于二叉查找树的思考

### 1.关于树型结构的特性与核心操作的返回值

==**树型结构**==的结构特性决定了像二叉树、二叉查找树等树型结构是==**具备完全包含性质**==的，绝大多数操作都是具备完全包含性质的问题。

**对于二叉树、二叉查找树等==树型结构的会改变树的结构的操作，比如插入与删除，这种会改变树的结构的操作，返回值应当是节点类型的指针，这样可以保证树型的结构在这些改变树的结构的操作之后能够及时更新到最新的状态==。**