# 有向图强连通分量

1. **强连通**：如果两个顶点$v_i,v_j$之间有一条从$v_i$到$v_j$的有向路径，同时还有一条从$v_j$到$v_i$的有向路径，则称两个顶点强连通(strongly connected)。
2. **强连通图**：如果有向图G的任意两个顶点都强连通，则称G为一个强连通图。
3. **强连通分量(Strongly Connected Components, SCC)**：有向图的**极大强连通子图**，称为强连通分量。

## 一、Tarjan算法

### 1. DFS生成树

有向图的DFS生成树：

![scc1.png](./scc1.png)

有向图的DFS生成树主要有4种边(不一定全部出现)：

1. **树边(tree edge)**：每次搜索到一个**还没有访问过的节点**的时候就形成了一条树边。

2. **返祖边(back edge)**：指向**祖先**的边。**==出现返祖边，意味着该祖先和该节点强连通。==**

3. **横叉边(cross edge)**：搜索时遇到一个**已经访问过的节点**，但是这个节点**并不是当前节点的祖先形成的**。

4. **前向边(forward edge)**：在搜索时**遇到子树中的结点**的时候形成的。

   > 前向边不会影响强连通性，因为已经访问的子树如果能够和祖先强连通，那么自然不受影响，如果无法强连通，加上前向边也没法强连通。
   >
   > 同理，横叉边也不会影响强连通性。

考虑DFS生成树与强连通分量之间的关系：

**如果节点u是某个强连通分量在搜索树中遇到的第一个结点，那么这个强连通分量的其余节点肯定在搜索树中以u为根的子树中**。u被称为这个强连通分量的根。

> 从强连通分量中的任意节点出发，都可以生成一棵搜索树。



### 2. Tarjan算法求强连通分量

在Tarjan算法中为每个节点u维护以下变量：

1. $dfn[u]$：深度优先搜索遍历时的节点u被搜索的次序。

2. $low[u]$：设以u为根的子树为$Subtree(u)$。$low[u]$定义为以下节点的dfn的最小值：

   + **$Subtree(u)$中的节点**。
   + 从$Subtree(u)$通过一条**不在搜索树上的==返祖边==能够到达的节点**，这要求**==出边的节点要在栈中==**，而横叉边因为是在另一个强连通分量中，所以不考虑，前向边不影响强连通性。

   $low[u]$的意义：从u**能够访问(回溯、dfs)到的最早的已经在栈中的节点，或者说自身所在强连通分量中节点的最小dfn**。

   如果==$dfn[u]=low[u]$，那么意味着**节点u就是一个强连通分量搜索树的根节点**==，逐个出栈节点到遇到u，这部分节点就是该强连通分量中的节点。

   在搜索树中，节点具有如下性质：

   + ==$dfn[u]\ge low[u]$==：节点至少可以访问到本身，如果能够访问到祖先节点的话，那么low值一定是小于dfn的。
   + 从根节点开始的一条路径上**dfn严格递增**，即一个节点的子树内的节点的dfn都大于该节点的dfn。而**low是严格非降的**(这是显然的，能返祖的话就都可以返祖，根节点的最终的low一定最小)。

按照深度优先搜索次序对图中节点进行搜索，在搜索过程中，对于节点u和与其相邻的节点v，v不是u的父节点，考虑3种情况：

1. **v未被访问**：继续对v进行深度优先搜索。在回溯过程中，用$low[v]$更新$low[u]$。**因为存在从u到v的直接路径，所以v能够dfs(回溯)到的已经在栈中的节点，u也一定能访问(回溯)到。**
2. **v被访问过，已经在栈中**：即已经被访问过，根据low的定义（能够回溯到的最早的已经在栈中的结点），则用$dfn[u]$来更新$low[u]$。
3. **v被访问过，已不在栈中**：说明v已经搜索完毕，其所在强连通分量已经处理，所以不用对其进行操作。

在一个强连通分量中有且仅有一个$dfn[u]=low[u]$，该节点一定是在深度遍历的过程中，该强连通分量第一个被访问的节点，**因为其dfn和low最小，不会被该强连通分量中的其他节点所影响。**

因此，在回溯的过程中，判定$dfn[u]=low[u]$是否成立，如果成立，那么栈中从u后面的节点构成一个SCC。



### 3. 代码

```c++
#define MAX_N 10010

int n;

vector<vector<int>> graph(MAX_N, vector<int>(0)); // 临接表存储图

vector<int> dfn(MAX_N, 0); // 深度优先搜索强连通分量的搜索树时访问的顺序，即时间戳
vector<int> low(MAX_N, 0); // 每个点在所在强连通分量中能够回溯到的最小节点dfn
int dfncnt;

stack<int> st; // 栈
vector<int> in_stack(MAX_N, 0); // 节点是否在栈中

vector<int> scc(MAX_N, 0); // 每个节点所属强连通分量的编号
vector<int> sz(MAX_N, 0); // 对应编号强连通分量中的节点个数 
int sc; // 强连通分量编号

void tarjan(int u) {
    if (dfn[u]) return ;
    st.push(u);
    in_stack[u] = 1;
    dfn[u] = ++dfncnt;
    for (int &v : graph[u]) {
        if (!dfn[v]) {
            // 如果v没有访问过，那么u-v是树边，访问，然后low[u] = min(low[u], low[v])，这样搜索树上的从根到孩子的low值非增
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else {
            // 如果v被访问过了，那么v可能是返祖边、横叉边、前向边。
            // 如果v在栈中，那么v可能是返祖边、前向边，这时一定可以形成强连通分量
            // 如果v不在栈中，那么v可能是横叉边、前向边，此时不用任何操作，因为v在另一个强连通分量中
            if (in_stack[v]) low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]) {
        // 如果当前节点dfn = low，那么这是一个强连通分量搜索树的根节点，栈中u及之后的节点都是该强连通分量中的点，弹出并标记
        ++sc;
        while (st.top() != u) {
            scc[st.top()] = sc;
            sz[sc]++;
            in_stack[st.top()] = 0;
            st.pop();
        }
        scc[st.top()] = sc;
        sz[sc]++;
        in_stack[st.top()] = 0;
        st.pop();
    }
}
```

