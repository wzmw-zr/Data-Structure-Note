# 凸包

**凸包**：在平面上能包含所有给定点的最小凸多边形叫做凸包。

实际上可以理解为用一个橡皮筋包含住所有给定点的形态。**凸包用最小的周长围住了给定的所有点**。

凸包的常见算法有：Jarvis算法，Graham算法，Andrew算法。

**解决凸包相关问题，最重要的是理解凸包的3个性质**：

1. **==从凸包最左侧点逆时针走，其余点都在凸包上当前边的左侧==。**（Jarvis算法）
2. **==从凸包最左侧点逆时针走，凸包上其余点相对于初始点的极角递增（根据相对初始点的极角和距离排序）==。**（Garham算法）
3. **==从凸包最左侧点逆时针走，走到凸包最右侧点，走过的是下凸壳，下凸壳上点x递增; 从凸包最右侧点逆时针走，走到凸包最左侧点，走过的是上凸壳，上凸壳上点x递减（根据x和y排序）==。**（Andrew算法）

这些算法需要注意共线和最后一条边。

## 1. Jarvis算法

基于一个凸包的性质理解Jarvis算法：

**==从凸包上一点开始顺着某一个方向走，那么其余点在当前向量同一侧（一直是左侧/右侧）==**。（逆时针走的话，那么其余点都在当前向量的左侧，轨迹总是左拐的）

Jarvis算法的思想：

+ 从凸包上某一点$A_1$开始（先找到凸包上一点，通常可以选择高度最高/低/左/右的点，一定是凸包上的点），选择点$A_2$，使得所有点都在$\vec{A_1A_2}$的左方或者右方，这里每次选择左方，需要比较所有点以$A_1$为原点的极坐标的角度，然后以$A_2$为原点，重复该步骤，依次找到$A_3,A_4,...,A_K$，直到遇到$A_1$，停止。

+ 关于给定原点$p$，如何找到点$q$，使得其余点$r$均在向量$\vec{pq}$的左边，使用**向量叉积**判断。

  向量叉积$\vec{a}\times \vec{b}=||a||.||b||\sin\theta$，$\theta$是$\vec{a},\vec{b}$之间的夹角。

  + 如果向量$\vec{pq},\vec{qr}$的叉积大于0，则表示两个向量之间的夹角小于180都，两个向量之间构成的旋转方向为逆时针，可以知道r一定在$\vec{pq}$的左边。
  + 如果向量$\vec{pq},\vec{qr}$的叉积等于0，则表示$p,q,r$在同一条直线上。
  + 如果向量$\vec{pq},\vec{qr}$的叉积小于0，表示两个向量之间的夹角大于180度，两个向量之间构成的旋转方向是顺时针，可以知道r一定在$\vec{pq}$的右边。

+ **关于从凸包上点$A_1$找$A_2$使得其余所有点在$\vec{A_1A_2}$左边的过程，如果找到点$r$在$\vec{A_1A_2}$右边，则将$A_2$更新为$r$，之前的点一定在$\vec{A_1r}$的左边，该过程的时间复杂度为$O(N)$，因此Jarvis算法的总时间复杂度为$O(N^2)$**。

> 需要注意在同一条直线上的点，使用一个数组表示和当前向量处于同一直线上的点，注意更新操作即可。



## 2. Graham算法

**基于凸包的一个性质理解Graham算法：**

**==从凸包的一个点出发，逆时针走，那么该路径上的点相对于初始点的极角是递增的，如果共线的话，除了最后一条边，距离是递增的==。==因此Graham先利用极角和距离进行排序，计算凸包==**

**Graham算法对平面上点按照相对起始凸壳点的极角与距离进行排序，使用栈来保存凸包上点**。

+ 首先选择凸包上的一个初始点bottom，可以选择y坐标最小的点作为起始点，将该点和原下标0的点交换即可，排序后（n - 1）个点即可，**将给定点集按照相对bottom为原点的极角大小进行排序，相同极角大小的按照距离进行排序**。
+ Graham算法也需要考虑共线的情况，主要是**共线的点在凸壳的最后一条边上，这需要从距离初始点距离最远的点开始考虑**。**将数组排序后，需要从尾遍历，将共线的有序数组尾部反转顺序**。
+ 遍历排序后与末尾共线处理后的数组，**如果当前点和上一条线之间的关系是右拐的，说明上一个点不应该在凸壳中，重复弹出栈顶元素直到当前点和上一条线共线或这左拐**。
+ **在所有点被遍历一遍后，留在栈中的点就是凸壳上的点**。



## 3. Andrew算法

Andrew算法利用的是凸包的一个性质：

**==选取凸包上最左和最右的点，从最左点开始逆时针走到最右点，认为这半部分是下凸壳，这些点的x是递增的; 从最右点逆时针走到最左点，认为这半部分是上凸壳，这些点的x是递减的==**。

+ 按照x对所有点排序，x相同按照y排序，计算凸包上最左和最右点。
+ 计算下凸壳，从最左点开始，顺序遍历排序后的数组，持续出栈直到当前点在当前边的左侧，因为x是递增的，所以这一定是下凸壳。
+ 计算上凸壳，从最右点开始，逆序遍历排序后的数组，**已经在下凸壳中的点跳过（除了最左侧点）**，持续出栈直到当前点在当前边的左侧，因为x递减，所以这一定是上凸壳，注意需要**检测上凸壳最后加入的点是否合法，所以需要再次插入最左侧的点进行判别，因此上凸壳中是包含重复的最左侧点的，需要单独弹出**。