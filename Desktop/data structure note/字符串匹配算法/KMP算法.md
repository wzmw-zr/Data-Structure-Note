# $KMP$算法

## 一、$KMP$算法的基本思想

$KMP$算法在BF算法基础上的优化：==**模式串和母串发生失配时，失配位置前的部分是相同的，通过寻找这部分的相同前缀、后缀来减少不必要的比较操作。**==

正因为失配位置前的位置是母串和模式串是相同的，所以我们可以在预处理中记录关于相同前后缀的信息，==**在预处理中我们记录的是最长相同前后缀的信息，这用到的就是next数组。**==



### 1.发生失配之后会遇到的3类情况

#### (1)在失配位置前的部分的一个相同前缀、后缀，从此后缀开始能够继续匹配

**如果失配位置前的区间有相等前缀和后缀的话，就意味着这个后缀作为模式串新的开头可能能够继续匹配甚至会获得成功匹配的结果**。那么我们就需要来对相同前后缀进行检查。如果我们找到一个相等前后缀能够继续匹配，那么我们就可以继续进行。

#### (2)在失配位置前的部分虽然有相同的前缀、后缀，但是处理完所有的相同前后缀都不能继续匹配

如果我们对所有相同前后缀检查过了，都没能继续匹配，那么说明如果后面能够成功匹配，那个成功匹配的区间和当前的这个区间是不会有交集的。接下来进入下一个区间。

####  (3)在失配位置前的部分没有相同的前缀、后缀

**如果失配位置前的部分没有相等的前缀和后缀，而最终能够匹配的话，那么这失配位置前的部分和最终匹配的区间是绝对不会有交集的**，这一点可以通过反证法来证明。那么就说明我们**不需要在失配的那个区间停留，直接进入下一个区间。**



### 2.预处理中记录最长前后缀的原因

由于发生失配时，我们需要对失配位置前的区间的所有相同前后缀进行检查，查看是否有哪一个相同前后缀能够继续进行匹配。而我们肯定是要检查最长的前后缀的。

接下来，证明：==**如果失配位置前的部分有次长相同前后缀，则次长相同前后缀一定是最长前后缀中任意一个的最长相同前后缀。**==
$$
证明：\\
如果失配位置前的部分还有次长相同前后缀，那么这个次长前缀一定在最长前缀的开头，\\而次长后缀一定在最长后缀的末尾，由于最长相同前后缀的性质，次长相同前后缀一定是\\在最长前缀中 (当然也是在最长后缀中)。\\而关于这个次长相同前后缀是最长相同前后缀任一的最长相同前后缀是可以通过反证法证明的。
$$
**因此，我们只需要在预处理中记录最长相同前后缀的信息，其余的前后缀的信息可以通过相同前后缀获得次长相同前后缀，这样迭代进行，直到能够继续匹配或者检查完了所有的相同前后缀都无法继续匹配，此时直接进入下一个区间。**



## 二、$KMP$算法的基本原理

记$len_s$是字符串$s$的长度，$S_a^{b}$是字符串$S$从第$a$个字符到第$b$个字符的一个子串。

在下图中，$P_a$ 模式串$T$的一个前缀，$P_b$**是子串$S_0^i$的一个后缀(当然也是子串$T_0^i$的一个后缀)**，$P_a=P_b$。**并且==$P_a$和$P_b$是所有相等前缀和后缀中长度最大的。==**

模式串$T$和母串$S$在位置$i+1$的时候匹配失败。在$KMP$算法中，利用了$P_a$和$P_b$相等的这一特点，下一步直接将下标为$len_{P_a}$的字符$T[len_{P_a}]$与$S[i+1]$进行比较**。==因为模式串$T$和母串$S$在位置$i+1$的时候匹配失败说明了$S_0^i=T_0^i$==，**又因为$P_a=P_b$，所以$P_a$也可以看成是串$S_0^i$的后缀，那么下一步就匹配就可以直接跳到$T[len_{P_a}]$与$S[i+1]$进行比较了。

![string match](/home/zr/Desktop/data structure note/string match.png)

那么，我们实际上只需要知道第$i$个位置上的$len_{P_a}$的值就能在匹配失败的时候进行下一次匹配，那么我们可以将这个值就记录在next数组里。通常为了方便，我们只需记录前缀最后一个字符的下标，即$next[i]=len_{P_a}-1$。

==**既然模式串$T$和母串$S$在位置$i+1$的时候匹配失败说明了$S_0^i=T_0^i$，那么这就意味着我们可以预处理模式串$T$**==，这就可以得到上面的next数组。



## 三、对于next数组的处理

### 1. next数组中元素的含义

关于next数组中元素的确定：

(1)在next数组中，如果子串$T_0^i$有相同的前缀和后缀(最大的)，那么$next[i]$纪录的最长前缀里最后一个字符的下标位置   (**前缀和后缀不包括子串本身**)。

(2)如果不存在相同的前缀和后缀，则$next[i]=-1$ 。



### 2. next数组的计算思路

**next数组的计算实际上可以看作是模式串自身的匹配过程。**

next数组的计算思路如下：

假设我们已经计算出了$next[i-1]$的值，现在要求$next[i]$(i就是当前的字符所在位置)的值。**思路就是从$T_0^{i-1}$的最长相等前缀和后缀开始，判断是否可以构成$next[i]$所需的最长相等前缀和后缀，若不能，就不断的寻找$T_0^{i-1}$中次长的相等前缀和后缀来进行判断，直到能够构成$T_0^i$的最长相等前缀和后缀，或者没有相等前缀后缀，此时返回-1。**具体的算法流程如下：

1. 比较$T[i]$和$T[next[i-1]+1]$的值;
2. 如果相等，则$next[i]=next[i-1]+1$;
3. 如果不相等，则继续比较$T[i]和T[next[next[i-1]]+1]$的值，这里可以将子串$T_0^{next[next[i-1]]}$看成是$T_0^{i-1}$的次长相等前缀和后缀。
4. 重复以上操作直至next的值为-1。

==**为了操作的可行性与简单性，使用外一层作用域的变量j来保存当前位置的前一个位置的最长公共前后缀长度，当然也可以在循环内定义，不过这样操作就复杂一些了。**==



### 3.关于next数组的优化

**正常情况下，next数组记录的当前区间的最长相同前后缀的前缀最后一个元素的位置，而优化之后，记录的可能就不是了。**

==但是这样对next数组进行优化之后最长相同前后缀的概念将会是不准确的了。==

（1）在$T[i]和T[next[i-1]+1]$的值相等的时候，是直接找到了最长前缀和后缀;

（2）但是如果$T[i]\neq T[nex[i-1]+1]$的时候，很有可能在持续迭代的过程中一直会有$T[next[i-1]+1]=T[next[next[i-1]]+1]$，那么我们就可以在构造next数组的时候合并这种情况，直接操作$next[i]=next[next[i-1]]+1$,这样我们可以避免不必要的匹配，直接一步到位，在一开始比较$T[i],T[next[i-1]+1]$的时候，相等的话可以正常进行，不想等的话可以避免不必要的比较操作。

**这实际上是在最长相同前后缀和次长相同前后缀的下一个元素相同时的合并技巧，后面可以匹配的时候我们是可以正确判断能够继续匹配，但是一旦不能匹配我们可以跳过中间这些连续的“相同情况”。**



## 四、$KMP$算法的自动机本质的理解

$KMP$ 算法的本质思想是自动机理论中的$DFA$，当前的状态根据输入可以转移到某一个确定的状态。构建的next数组就是状态转移的一个依据。

事实上，$KMP$算法在构建next数组以及执行对母串的匹配时，都使用到了自动机理论。

使用自动机，首先需要定义一个初始状态(即自动机的初始状态)，之后根据输入以及状态转移的规则来进行状态转换，到达终止状态后退出。

$KMP$算法的代码如下：

```c++
int kmp(char *s, char *t) {
    int *next = (int *) malloc(sizeof(int) * strlen(t));
    //next[0]必须是-1
    next[0] = -1;
    // 构建next数组，这是一个使用自动机的过程，j是自动机的状态，初始化为-1
    // 在构建next数组时，t[i]作为自动机的输入，由于next[0]已经赋值，相当于t[0]已经被处理，输入从t[1]开始
    for (int i = 1, j = -1; t[i]; i++) {
 // 失配时的状态转移规则，自动机状态j不为-1且t[i] != t[j + 1]时按照j = next[j]规则转移状态
        while (j != -1 && t[i] != t[j + 1]) j = next[j];
        // 在退出循环时判断退出原因，若是t[i] == t[j + 1],则按照j++转移状态
        if (t[i] == t[j + 1]) j++;
        // 构造next数组
        next[i] = j;
    }
    // 对木传进行匹配，这是一个使用自动机的过程，j是自动机的状态，初始化为-1
    // s[i]是自动机的输入
    for (int i = 0, j = -1; s[i]; i++) {
// 失配时的状态转移规则：在j ！= -1且s[i] != t[j + 1]时按照j = next[j]的规则转移状态
        while (j != -1 && s[i] != t[j + 1]) j = next[j];
//成功匹配时的状态转移规则
        if (s[i] == t[j + 1]) j++;
// 判断是否到达匹配完成的状态
        if (!t[j + 1]) return i - strlen(t) + 1;
    }
    return -1;
}
```



## 五、$KMP$算法的特点与本质

### 1.$KMP$算法的特点

(1)我们**实际上每次是拿母串中的一个字符到模式串中找位置，而在这个过程中，母串的指针是不会移动的，只是模式串的指针在跳**;

(2)**母串的指针只会往前走，不会有回溯操作**，所以我们在处理母串的时候，**甚至只需要一个字符就可以完成对整个母串的匹配。**

**由于$KMP$算法无需存储全部的母串，所以，$KMP$算法可以用于流式数据(==所有适合流式数据的算法都适合大数据==)的处理**。此时只有模式串的指针在跳动，当模式串的指针移动到最后，那么就代表匹配完成。

(3)$KMP$ **算法使用时，我们是要把整个母串给处理一遍的。**

### 2.$KMP$算法的本质

$KMP$算法的本质思想就是$DFA$(确定性有穷状态机)，我们可以通过当前的状态，根据输入，跳转到后面的确定状态。

在$KMP$算法中，预处理的next数组就是一个$DFA$，以母串的下一个字符作为输入，从当前状态，跳转到新的状态。

由此，我们可以思考，在编译原理中的词法分析部分学习的$DFA$和$NFA$，是用来处理字符串匹配问题的，这部分内容被称为自动机理论，后面还有的SHIFT-AND算法是$NFA$思想的体现。

并且，我们可以注意到$DFA$和$NFA$在进行词法分析的时候处理的实际上都是流数据，由此我们可以通过自动机理论实现一些能够处理流数据的算法。



