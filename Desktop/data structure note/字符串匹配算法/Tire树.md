# Trie树

## 一、Trie树的定义

Tire树又称为字典树或者单词查找树，是一种树形结构的数据结构，常**用于大量字符串的检索、去重、排序等**。**Tire树利用字符串的公共前缀，逐层建立起一棵多叉树。**

在检索时类似于在字典中查找单词，从第一个字符开始遍历在Tire树中一层一层往下查找，查找效率可以达到$O(n)$ ，n为查找字符串的长度。

![Trie2](/home/zr/Desktop/data structure note/字符串匹配算法/Trie2.png)

## 二、Trie树的本质

Trie树实际上是一种DFA。在Trie树的结构中，所有的节点对应这一个DFA状态，所有直接从父节点到子节点的被标记的边对应一个DFA转换，即接收一个字符，会发生的转换。

那么，使用Trie树进行查找时，是从头节点到尾节点(成词节点)，从关键词串中一个一个读取字符来决定要转移的下一个状态。

如果在处理完关键词串中的字符之后我们到达了成词节点，那么就可以退出。

但是如果在某一些节点失败的话，原因可能有两个：

（1）当前状态没有以当前字符标记的分支

（2）字符串已经处理完了，但是当前的状态是未终止的状态



## 三、Trie树的特点

Tire树有以下特点：

1. Tire树的根节点上不存储字符，其余节点上存且只存一个字符。
2. 从根节点出发，到某一节点上经过的字符，即是该节点对应的前缀。
3. 每个节点的孩子节点存储的字符各不相同。
4. Tire树牺牲空间来换取时间，当数据量很大时，会占用很大的空间。如果字符串均由小写字母组成，则每个节点最多会有26个孩子节点，则最多会有$26^n$个用于存储的节点，n为字符串得最大长度。



## 三、Trie树的结构定义

Trie树中，字符是边(就是作为转换的输入)，实际的数据域中存的是节点是一个字符串的末尾的信息。

```c++
typedef struct Node {
    // flag表示当前节点是否为成词节点，也就是一个终止状态，0表示不是终止状态，1表示是终止状态
    int flag;
    // 指针域表示边，通过字符转成一个数字作为下标来表示哪一个指针域表示哪一个字符
    struct Node *next[BASE];
} Node;
```



## 四、Trie树的结构操作

Trie树的基本结构操作有：（1）初始化节点（2）插入字符串（3）查找字符串（4）Trie树的释放（5）Trie树的字符串输出(**这个可以作为采用递归一个解决具有完全包含关系问题**)

### 1.初始化节点

```c++
Node *getNewNode() {
    Node *p = (Node *) calloc(sizeof(Node), 1);
    return p;
}
```



### 2.字符串插入

Trie树中的字符串插入操作，就是动态建立Trie树的操作。

```c++
inline int code(char ch) {
    return ch - BASE_LETTER;
}

void insert(Node *root, char *str) {
    // p是DFA的状态
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        // 每次以一个字符作为输入，判断这个边下面是否还有状态，如果没有就新建一个状态节点
        if (!p->next[code(str[i])]) p->next[code(str[i])] = getNewNode();
        p = p->next[code(str[i])];
    }
    // 到了字符串末尾，给最后的状态标记为终止状态
    p->flag = 1;
}
```



### 3.字符串查找

Trie树的字符串的查找就是DFA进行字符串匹配的过程，从DFA的初始状态开始，将字符串中的一个个字符作为输入，进行状态转换与错误处理。

```c++
int query(Node *root, char *str) {
    // 必须的操作，当前的DFA不能为空
    if (!root) return 0;
    // p是DFA的状态，初始化为root
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        // 逐个读入字符串中的字符，进行状态转换
        p = p->next[code(str[i])];
        // 判断转换是否出错
        if (!p) return 0;
    }
    // 由于当前查找的字符串虽然在Trie树中可以局部匹配出来，但是这个不是终止状态
    // 所以要返回的是最后匹配节点的flag
    return p->flag;
}
```



### 4.Trie树的销毁

Trie树的销毁也是一个具有完全包含关系的问题，采用递归的方式进行销毁。

```c++
void clear(Node *root) {
    if (!root) return ;
    for (int i = 0; i < BASE; i++) clear(root->next[i]);
    free(root);
}
```



### 5.Trie树的遍历

Trie树的遍历也是一个具有完全包含关系的问题，但是这里采用了递归解决具有完全包含关系问题的一种技巧，在进行递归时，加上当前解决的问题所在的层数。

```c++
// k代表层数，这是使用递归方式解决具有完全包含关系问题的另一个技巧
void output(Node *root, int k, char *buffer) {
    if (!root) return ;
    if (root->flag) {
        printf("%s\n", buffer);
    }
    for (int i = 0; i < BASE; i++) {
        buffer[k] = BASE_LETTER + i;
        // 这个操作也是需要注意的，要保证遇到终止状态时，字符串有'\0'作为结尾标识。
        buffer[k + 1] = '\0';
        output(root->next[i], k + 1, buffer);
    }
}
```



## 五、Trie树的应用

**Tire树常用于字符串的快速检索，排序与查重，文本的词频统计等**。Trie树维护的是字典序，如果想用于对数值的排序，比如9和11,我们需要将9变成09。

对于Trie树按照前序遍历顺序找到的字符串是按照字典序排序好的。Trie树没有用到比较操作。

> 所有基于比较的排序算法，时间复杂度的下界最小也是$O(n\log{n})$，要想突破这个下界，就需要设计不基于比较的算法。

