# 静态查找表—查找算法

**静态查找表的数据结构通常是包含一个线性表(如顺序表或者链表，由于链表具有的基本不受空间限制的特点，较多使用于顺序查找上，而顺序表较多使用于折半查找)**，用来存放查找的数据元素的集合。

静态查找表的常用查找算法有顺序查找，折半查找，三分查找，分块查找。

## 一、顺序查找

**顺序查找(又称线性查找)，是指在线性表(顺序表、链表都可以)中进行的查找算法。**

顺序查找按照查找表中数据的性质，分为对一般的无序线性表的顺序查找和对按关键字有序的线性表的顺序查找。

> ==由于链表具有的基本不受空间限制的特点，较多使用于顺序查找上==

### 1.一般的无序线性表的顺序查找

对于一般的线性表的查找，基本思想是从线性表的一段开始，逐个比对关键字是否满足给定的条件。若找到某个元素的关键字满足给定的要求，则查找成功，若一直找到线性表的另一端仍未有满足要求的元素，则查找不成功。

对于有n个元素的查找表，每个元素的查找概率一样，那么查找成功的平均查找长度为
$$
ASL_{success}=\sum_{i=1}^{n}P_i*i=\frac{n+1}{2}
$$
而当查找不成功时，与查找表中各个元素的比较次数为n次，因此查找不成功的平均查找长度为
$$
ASL_{failed}=n
$$

### 2.对关键字有序的线性表的顺序查找

对关键字有序的线性表的顺序查找在查找成功时的平均查找长度是一样的，但是在查找不成功的平均查找长度减少了。假设对于所有查找不成功的关键字key，落在$(-\infty,a_0),(a_0,a_1),...(a_{n-2},a_{n-1}),(a_{n-1},+\infty)$这n+1个区间的概率是相等的，都是$\frac{1}{n+1}$，那么查找不成功的平均查找长度是：
$$
ASL_{failed}=\frac{1+2+3+...+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}
$$


## 二、折半查找(二分查找)

**折半查找可以用于有序顺序表的查找(也可以用于在单调函数中求解)**的，折半查找的基本流程如下：

1. 首先确定待查关键字在有序查找表中的范围。通常用两个下标表示初始范围，left=0, right = length -1
2. 然后用给定的关键字和查找表中间的位置，下标为$mid=\frac{left+right}{2}$的元素的关键字进行比较，若相等，则查找成功，否则根据中间位置元素和关键字的大小关系来确定新的查找区间
3. 如此重复进行，直到查找成功或者范围缩小为空($left > right$)，即查找不成功为止。

折半查找查找成功的平均查找长度和查找不成功的平均查找长度的事$O(\log{n})$级别的，但是折半查找只适用于有序顺序表的情况。

### 1.二分查找的一些特殊情况以及特殊情况下mid的取整选择

在一堆连续的1后接着一堆连续的0,求最后一个1的下标。

**使用虚拟的头指针来防止全是0的情况。**（这个算是应对特殊情况的技巧）

在一堆连续的0后接着一堆连续的1,求第一个1的下标。

**使用虚拟的尾节点来防止全是0的情况。**

> ==**关于二分查找的mid的选择的思考：**==
>
> 一般情况下的二分查找对于mid是不需要考虑上下取整的问题的，但是有时候在一些特殊的问题中，我们要找的是一些特殊性质的数字，那么救赎要注意上下取整对最后的结果的影响。
>
> 在寻找第一个1的这个例子中，考虑到正常我们的除法都是向下取整，所以最终获得的一定就是第一个1。
>
> 但是在寻找做后一个1的过程中，由于正常除法运算的下取整特性，可能会导致我们错过了最后一个1,返回的是倒数第二个1的位置，因此这种时候就需要进行上取整。
>
> **==选择mid的标准是根据目标来决定的，如果目标具有第一性(位置最靠前的那种)，那么就可以下取整，如果目标具有最后性，那么就需要进行上取整了。==**

**另外，正常情况下head和tail的终止条件是两者交错了， 但是也需要注意将head和tail重合作为终止条件的特殊情况。**

正常情况和特殊情况的代码如下：

```c++
int binary1(int *arr, int len, int val) {
    int l = 0, r = len - 1;
    while (l <= r) {
        int mid = (l + r) >> 1; 
        if (arr[mid] == val) return mid;
        if (arr[mid] < val) l = mid + 1;
        else r = mid - 1;
    }
    return -1;
}

//000000111111：找第一个1,这实际上是一类问题的抽象：在一堆数据中找到第一个满足要求或者满足某些性质的第一个元素(下面的也是对另一类问题的抽象)
int binary2(int *arr, int len) {
    int l = 0, r = len, mid;
    // 使用二分查找的时候需要注意循环退出条件，这是会根据题目要求而变化的
    // 一般的二分查找的循环退出条件是l <= r,这是因为需要处理找不到元素的情况
    // 但是这里，循环的退出条件是l < r，这是因为当l == r时，通常就是找到了我们的目标，当然在后面处理一些极端情况
    while (l < r) {
        mid = (l + r) >> 1;
        if (arr[mid]) r = mid;
        else l = ++mid;
    }
    return (mid == len ? -1 : mid);
}

int binary3(int *arr, int len) {
    int l = -1, r = len - 1, mid;
    while (l < r) {
        mid = (l + r + 1) >> 1;
        if (arr[mid]) l = mid;
        else r = --mid;
    }
    return mid;
}
```



### 2.关于应不应该使用mid作为返回值的思考

在正常情况下，我们使用mid作为返回值是完全可以的，这是因为正常情况下我们找的是数字是否存在，存在的话直接返回下标就可以了，而且这个是正确的做法。

**但是，在不是寻找数字是否存在，而是找一些特殊性质的数字时，此时mid表示的数据可能与真实的数据之间存在一步操作差距，这是因为解决的问题的目标发生了性质上的变化。**

那么在要查找的是一些特殊性质的元素的时候，我们最好是以最后恰好契合要求的那个变量来作为返回值，而不必陷入必须使用mid的死胡同。

**或者另一种解决措施就是mid在原本进行+1, -1的地方使用++mid, --mid,这样也可以。**

## 三、三分查找(查找的是凹凸函数的区间极值)

在一个单调序列里，我们可以使用二分查找来进行快速的查找，同理，二分查找也可以应用于一个单调函数中精确求解某一点的值。

**==三分查找==可以用来解决函数是一个==凸性函数==(区间内具有极大值点的函数)或者==凹性函数==(区间内具有极小值点的函数)的==求极值点的问题==。**

### 1.三分查找的过程

假设一个凸性函数$f(x)$，要在闭区间$[L,R]$内查找函数的极大值点$T$。

对于凸性函数，有如下性质：

对于任意两点a和b，如果$L\le a\le b \le T$，则有$f(a) < f(b)$;如果$T \le a \le b \le R$,则有$f(a) > f(b)$。



具体的三分查找过程如下：

1. 首先将区间$[L,R]$平均分为三部分：$[L,m_1], [m_1, m_2],[m_2, R]$。
2. 计算三等分点$m_1$和$m_2$对应的函数值$f(m_1)$和$f(m_2)$。
3. 比较$f(m_1)$和$f(m_2)$的大小。
   + 若$f(m_1)>f(m_2)$：则说明点$T$一定不在区间$[m_2,R]$ 内可以将右边界$R$更新为$m_2$
   + 若$f(m_1)<f(m_2)$：则说明点$T$一定不在区间$[L,m_1]$内，可以将左边界$L$更新为$m_1$
   + 若$f(m_1)=f(m_2)$：则说明点$T$ 一定在区间$[m_1,m_2]$内，也可以归结为上面的两种情况中去
4. 重复以上操作直到区间的范围精度达到要求，选择左右区间点都可以作为极大值点$T$。

### 2.三分查找时间复杂度

三分查找每次都会将区间平均分为三等分，在一次比较之后都会舍弃一个区间，即，在一次比较之后，都会将区间长度缩减为原来的$\frac{2}{3}$，所以三分查找的时间复杂度为$O(\log{n})$。



## 四、分块查找

分块查找的基本思想是将一个线性表分成若干个子表，在查找时，先确定目标元素所在的子表再在该子表中去查找它。

**分块查找也被叫做索引顺序查找，在分块查找方法中，我们需要建立一个索引表。索引表中包含两类信息：关键字和指针。**其中，关键字指的是每个子表中的最大关键字，指针则表示该子表中第一个元素在整个表中的下标。

索引表中的每一项是按照关键字进行排序的，因此，我们可以很容易在索引表中使用顺序查找或者折半查找的方法来找到目标元素所在的子表。而在每一个子表中，元素的排列是随意的，我们只能通过顺序查找的方式在子表中完成最终的查找工作。

分块查找适用于现行表需要频繁的动态变化的情况，但是正常来说我们很少使用分块查找。