# 哈希表(哈希算法)

## 一、哈希表概念

哈希表又叫散列表，关键值通过哈希函数映射到数组上，查找时通过关键值直接访问数组。

哈希函数指的是关键值和存储位置建立的对应关系，查找时只要根据这个关系就能找到目标位置。

一般一次查找就能找到目标位置，但是有的时候有些关键字需要多次比较和查找才能找到，这是因为在哈希表中可能存在关键字不同但是哈希地址相同的情况，即产生了冲突。一般情况下，冲突是不可避免的。因为关键字集合往往比哈希地址集合大的多。

要提高哈希表的查找效率，关键在于**合理地构造哈希函数**和优秀的**解决冲突的方法。**

> 依旧要记住：数据结构定义了一个性质，以及一些维护这种性质的操作。



## 二、常见的哈希函数构造方法

哈希函数的作用：将给定类型的数据映射为一个整型数据，通过这个整型数据获得相应的地址。

### 1.直接寻址法

取关键字的值或者关键字的某个函数的变换值，线性的映射到存储地址上。如果关键字的数量和跨度不是很大，直接寻址法是最为简单有效的构造方法，并且还可以避免冲突。

但是如果关键字的数量和跨度很大的时候，这种方法就用不了了，因为会没有足够的空间来存储。

### 2.除留余数法

将关键字对整数p取的余数直接作为存储地址，整数p一般是小于等于哈希表长度size的最大质数。

如果关键字不是整数，比如是一个字符串，可以先做一个转换，然后再对p取余。

> 设计哈希函数没有统一的方法，同一个哈希函数不一定适用所有问题。

> **==设计哈希函数要达到的两个要求：（1）计算简单，计算复杂的哈希函数会增加查询时间（2）关键字尽可能均匀分布到存储地址上，这样可以减少冲突==**



## 三、处理冲突的方法

构造优秀的哈希函数可以减少冲突，但是一般情况下冲突是不可避免的。

**冲突处理是包含在哈希表的插入与查找操作中的。**

### 1.开放地址法

==开放地址法容易产生堆聚现象，并且不适合大规模数据存储，容易产生冲突，处理冲突有需要花费大量时间，不容易删除元素，节点规模很大时会浪费很多空间，**所以哦我们更多使用的处理冲突的方法是链地址法**==

如果发生冲突，那么就使用某种策略寻找下一个存储地址，直到找到了一个不冲突的地址或者找到了关键字，否则一直按照这种策略继续查找。如果冲突次数达到了上限则种植程序，表示关键字不存在哈希表中。一般常见的策略如下：

#### (1)线性探测法

如果当前的冲突地址为d，那么接下来几个探测地址为d+1, d+2,的+3等，也就是从冲突地址往后一个一个探测。

线性探测法查找哈希冲突的算法流程：

```
1. 用哈希函数找到字符串 S 的初始位置，初始化冲突次数。
2. 从当前位置往后查找，找到第一个未发生冲突的位置 K（当前位置上如果存储的字符串不是 S 即视为发生冲突）。查找过程中记录发生冲突的次数 T，如果 T 大于等于表长，则结束算法，表示查找失败。
3. 如果位置 K 上的元素就是所查找的字符串，表示查找成功，否则表示查找失败。
```



#### (2)线性补偿探测法

线性补偿探测法中形成的探测地址为d+m， d+2×m，d+3×m等，与线性探测法不同，这里的查找单位是m，为了能够遍历到哈希表中的所有位置，一般设置m和表长size互质。

#### (3)随机探测法

随机探测法探测的是一个随机序列。

#### (4)二次探测法

形成的探测地址为$d+1^2,d-1^2, d+2^2, d-2^2$等，这种方法在冲突位置左右跳跃这寻找探测地址。



开放地址法计算简单快捷，处理起来方便，但是也有不少缺点。**线性探测法容易形成"堆聚"情况**，即很多记录连在一起，而且一旦形成"堆聚"，记录会越聚越多。

另外，开放地址法都有其一个缺点，删除操作十分复杂，我们不能直接删除了关键字所在的记录，否则在查找删除位置后面的元素时，可能会出现找不到的情况，因为删除位置上已经形成了空地址，查找到这里时终止查找。



### 2.链地址法

链地址法将所有哈希地址相同的节点构成一个单链表，但链表的表头节点存在哈希数组中。了；**链地址法常用在经常插入和删除的情况下。**

链地址法的优点：

（1）不会出现"堆聚"现象，哈希地址不同的关键字不会发生冲突

（2）不需要重建哈希表，在开放地址法中，如果哈希表中存满了关键字就需要扩充哈希表然后重建哈希表，而在链地址法中，节点都是动态申请的，不会出现哈希表中存满关键字的情况。

（3）相比开放地址法，关键字删除更方便，只需要找到这个节点，然后删除就行。

>当关键字规模较小时，开放地址法比链地址法更节省空间，因为用链地址法可能会存在哈希数组出现大量空地址的情况。
>
>而在关键字规模较大的情况下，链地址法会比开放地址法跟节省空间。



### 3.再哈希法

当数据发生冲突时，使用另一个哈希函数再一次进行哈希。



### 4.开辟溢出缓冲区

实际上再哈希法和开辟溢出缓冲区不常用。



## 四、哈希表的扩容(开放地址法时使用)

在程序执行时，如果当前的元素已经存在哈希表当中，就直接返回一个值结束这次插入操作。除此之外，我们规定，当冲突次数小于表长的一半时，我们可以直接将字符串插入到哈希表中;但是，如果发生的冲突的次数大于表长的一半时，就需要调用重建函数去重建哈希表（此时认为发生了“堆聚”现象）。

哈希表的重建操作类似于顺序表的扩容操作，哈希表的重建算法流程如下：

```
1. 开辟一段和当前哈希表等大的临时存储空间。
2. 将原哈希表里的关键字一一复制到临时数组里。
3. 申请一个大小是现在两倍的新的存储空间，释放原空间。
4. 将新空间里的存储地址初始化。
5. 将关键字从临时数组复制到新的空间，释放临时空间。
```



## 五、哈希表结构定义

> 哈希：将高维转换到低维的映射关系，高维的含义是有多个值，低维的含义是有一个值。==换句话说这就是多对一的一种映射，因此就会产生冲突。==

一般来说，我们开辟的哈希表的大小正常是要存储数据数量的2倍。

当我们使用链地址法解决冲突时，哈希表的结构定义如下：

```c++
typedef struct node {
    char *str;
    struct node *next;
} Node;

typedef struct hashtable {
    // 虽然我们知道结构体之间可以互相赋值，但是在使用链表这种节点具有指针域的数据结构的时候，该用指针的还是使用指针。在使用链表这种结构的时候还是尽量都使用指针。
    Node **data;
    int size;
} HashTable;
```

**在使用哈希表的时候，我们通常使用链地址法，而在使用链表的时候，对于结构体这种数据结构，虽然我们可以使用结构提直接赋值，但是一般情况下还是使用指针类型方便。**

不过这一点还是根据情况来确定，一般来说使用结构体指针的话盘空操作比较方便。



## 六、哈希表的结构操作

### 1.哈希表的插入

使用链地址法的哈希表的插入操作流程：

（1）计算hash值，根据计算得到的hash值计算元素在数组中的下标

（2）将元素插入到数组下标对应的链表中，采用头插法，因为简单，耗时少。

```c++
// hash函数，用来计算对于关键字的映射值，这里也就是数组的下标
int BKDRHash(char *str) {
    int seed = 31, hash = 0;
    for (int i = 0; str[i]; i++) hash = hash * seed + str[i];
    //由于此处的映射值是数组的下标，所以要保证hash值为正数，取模的问题在外卖你解决。
    return hash & 0x7fffffff;
}

int insert(HashTable *h, char *str) {
    int hash = BKDRHash(str);
    int ind = hash % h->size;
    h->data[ind] = init_node(str, h->data[ind]);
    return 1;
}
```



### 2.哈希表中元素的查找

链地址法在哈希表中查找元素的过程实际上是和哈希表的插入类似，操作流程如下：

（1）计算待查找元素的hash值，之后根据hash值获得其在数组中链表的下标;

（2）在对应的链表中查找元素是否存在。

```c++
int search(HashTable *h, char *str) {
    int hash = BKDRHash(str);
    int ind = hash % h->size;
    Node *p = h->data[ind];
    //一个编程的技巧启发：当在while循环中使用if判断的时候，看看能不能合并到while的循环条件中。
    while (p && strcmp(p->str, str)) p = p->next;
    return p != NULL;
}
```



## 七、关于哈希表使用及编程技巧的一些思考

### 1.哈希表这种数据结构的结构操作组成

哈希表核心的几个操作：

1. 哈希函数：用来计算在哈希表中的地址(或许需要取模运算)。
2. 插入元素到哈希表(需要用到哈希函数与冲突处理)
3. 在哈希表中查找元素(需要用到哈希函数与冲突处理)



### 2.哈希表的用途是查找元素是否在哈希表中(等值查询)

工业上通常使用链地址法作为哈希表处理冲突的方法，使用哈希表，最重要的几个组成元素：

+ hash函数，用于计算hash值，作为确定元素在hash表中下标的计算依据(通常采用除留取余法来获取实际的下标值)
+ 哈希表的插入操作，实际上就是建立hash表
+ 哈希表的查找操作，查找元素是否在hash表中
+ 哈希表的元素删除操作，使用链地址法，先查找，然后删除，实现较为简单。



### 3.关于while循环中的if语句省略

当使用while循环时发现while循环中有if语句，那么就考虑是否可以将if的条件合并到while循环的判断条件里，可以化简代码。



### 4.哈希算法的实际应用

####   (1)场景一：安全加密

​    日常用户密码加密通常使用的都是 md5、sha等哈希函数，因为不可逆，而且微小的区别加密之后的结果差距很大，所以安全性更好，**使用hash算法处理过的数据存储到数据库中，即便整个数据库被拖库，密码等重要信息也是难以恢复的。**

####   (2)场景二：唯一标识 

​    比如 URL 字段或者图片字段要求不能重复，这个时候就可以通过对相应字段值做 md5 处理，将数据统一为 32 位长度从数据库索引构建和查询角度效果更好，此外，还可以对文件之类的二进制数据做 md5 处理，作为唯一标识，这样**判定重复文件**的时候更快捷。

####   (3)场景三：数据校验

​    比如从网上下载的很多文件（尤其是P2P站点资源），都会包含一个 MD5 值，用于校验下载数据的完整性，避免数据在中途被劫持篡改。**数据校验就是将整个文件作为hash函数的输入，输出的结果可以在传出完成后对数据进行校验。**

####   (4)场景五：散列函数

​    前面已经提到，PHP 中的 md5、sha1、hash 等函数都是基于哈希算法计算散列值

####   (5)场景五：负载均衡

​    对于同一个客户端上的请求，尤其是已登录用户的请求，需要将其会话请求都路由到同一台机器，以保证数据的一致性，这可以借助哈希算法来实现，通过用户 ID 尾号对总机器数取模（取多少位可以根据机器数定），将结果值作为机器编号。

####   (6)场景六：分布式缓存 

​    分布式缓存和其他机器或数据库的分布式不一样，因为每台机器存放的缓存数据不一致，每当缓存机器扩容时，需要对缓存存放机器进行重新索引（或者部分重新索引），这里应用到的也是哈希算法的思想。

 