# 二叉树的线索化

## 一、线索化二叉树基础知识

### 1.二叉树线索化的原因

二叉树线索化的原因：在二叉树退化为链表时，采用递归可能会引发爆栈。

> 二叉树的遍历采用递归 (使用栈)，是因为它需要回溯的功能。




### 2.线索化二叉树的实现(以中序遍历为例)

在二叉树中，能够有效利用的指针域只有$(n-1)$个，其中$(n+1)$个指针域都是没有利用的，此时可以利用这些指针域对二叉树进行线索化。

可以**将有空指针域的节点的空指针域指向原先需要回溯到的节点，这样就可以不需要使用递归了。**

**线索化二叉树的线索分为两种：后继指针(利用节点的空右指针域)，前驱指针(利用节点的空左指针域)。**前驱与后继都被称为线索。

**为了区别线索与实际的指向左右孩子的指针，需要对指针域加上标记(rtag, ltag)。**

在中序遍历中，一个节点的前驱是当前节点左子树的最右侧叶子节点，后继是当前节点右子树的最左侧叶子节点。

> 只有空指针域才可以成为线索，原本指向左孩子或者右孩子的指针是不能成为线索的
>
> 在中序遍历中，整个树的最左指针域和最右指针域可以不用加上前驱和后继，因为这两个节点是不存在前驱、后继的，但是我们一般还是会将这两个节点的指针域指向一个节点，方便进行中序遍历以及中序的逆序遍历。

一个有左孩子的节点在寻找前驱时是需要到左子树中寻找最右空指针域的节点，一个有右孩子的节点在寻找后继时是在右子树中寻找最左空指针域的节点。

> 前驱是左子树右分支尽头的结点 
> 后继是右子树左分支尽头的结点 

**使用线索化就可以在遍历时不使用栈。**

**由于二叉树有前序遍历，中序遍历，后序遍历，所以线索化的方式也有3种。**



## 二、建立中序遍历线索化

建立线索的过程实际上是和遍历的方式有关系的，换句话说两者的格式类似，并且都是具有完全包含关系的问题，**线索实际上就是在遍历的过程中建立起来的，所以建立线索的时候也是需要使用栈的(递归)**。

在建立中序遍历线索化的过程中，**这是先建立前驱线索，之后再建立后继线索。需要使用一个静态全局的变量（静态变量即便是在递归中只会初始化一次）来记录前驱，该变量由于最开始的左子树最左节点是没有前驱的，所以一开始初始化为NULL。**之后在建立线索的过程中不断更新。

在建立前驱线索的同时，建立后继线索，当然最开始当pre为NULL的时候是不要建立的。

建立前驱要求节点的左孩子指针域为空，建立后续要求节点的右孩子指针域为空并且该节点本身不为空。

> 准备进行加线索的节点会遇到的三种情况：（1）当前节点度为0（2）当前节点度为2（3）当前节点度为1，根据标记的类型来判断是否可以加线索。

```c++
void build_thread(Node *root) {
    if (!root) return ;
    //最开始的前驱是NULL
    static Node *pre = NULL;
    //建立线索也是一个有完全包含关系的问题，可以分为左子树和右子树两个部分来进行处理，建立线索的顺序与目标遍历的顺序一致。
    build_thread(root->lchild);
    // 左孩子指针域为空，那么就建立前驱线索
    if (!root->lchild) {
        // 前驱线索赋值
        root->lchild = pre;
        //更新左指针域的类型
        root->ltag = THREAD;
    }
    //在建立完前驱之后，设置前驱的后继，要求前驱节点不为空，且右孩子指针域为空
    if (pre != NULL && pre->rchild == NULL) {
        // 更新信息
        pre->rchild = root;
        pre->rtag = THREAD;
    } 
    pre = root;
    // 建立右子树部分的线索
    build_thread(root->rchild);
    return ;
}
```



## 三、建立了中序线索后的遍历过程

在建立的线索之后的遍历过程：

（1）先找到原本遍历类型的起始节点

（2）然后寻找后继节点进行遍历，找后继节点分为两种情况：

+ 当前节点的右指针域正好指向后继节点
+ 当前节点的右指针域指向右孩子，则右子树中的最左节点就是后继节点

```c++
Node *most_left(Node *p) {
    //在建立了线索之后，指针域无法完全起到标识的作用，所以，需要依靠标识位
    //并且，在树中会比较常见的错误，就是在节点或者树的指针为空时进行了数据的访问，所以在树中对节点进行访问的时候，需要首先对节点是否为空进行判断。
    while (p && p->ltag == NORMAL) p = p->lchild;
    return p;
}

void output(Node *root) {
    //先找到原本中序遍历的开始节点，就是左子树的最左节点，此时这个最左节点是有前驱的
    Node *p = most_left(root);
    // 从这个节点开始需找后继来进行遍历
    //分两种情况：
    //（1）当前节点的右指针域就是指向后继节点的，直接获得后继节点
    //（2）当前节点的右指针域指向右孩子，那么就去右子树中寻找最左边的节点，这个就是后继节点
    while (p) {
        printf("%d ", p->data);
        if (p->rtag == THREAD) {
            p = p->rchild;
        } else {
            p = most_left(p->rchild);
        }
    }
    return ;
}
```



## 四、建立前序遍历线索化

**建立前序线索时需要注意：**由于前序遍历的顺序具有一定的特殊性，当一个叶子节点的父亲节点右指针为空，那么这个右指针就会又指向这个叶子节点，在后面造成无限循环并最终引发爆栈。

```c++
void buildThreadNode(Node *root) {
    if (!root) return ;
    static Node *pre = NULL;
    if (!root->lchild) {
        root->lchild = pre;
        root->ltag = THREAD;
    }
    if (pre && !pre->rchild) {
        pre->rchild = root;
        pre->rtag = THREAD;
    }
    pre = root;
    //需要判断根节点的左右指针标记，防止造成上面的引起死循环的情况
    if (root->ltag == NORMAL) buildThreadNode(root->lchild);
    if (root->rtag == NORMAL) buildThreadNode(root->rchild);
    return ;
}

void buildThreadTree(Tree *tree) {
    if (!tree) return ;
    buildThreadNode(tree->root);
    return ;
}
```



## 五、遍历前序线索化二叉树

对于前序线索化二叉树的遍历实际上是和中序线索化二叉树的遍历过程类似。



## 六、建立后序线索化二叉树

后序线索化二叉树的建立与中序线索化二叉树类似，并且没有前序线索化二叉树那样的特殊情况。

```c++
void buildThreadNode(Node *root) {
    if (!root) return ;
    static Node *pre = NULL;
    buildThreadNode(root->lchild);
    buildThreadNode(root->rchild);
    if (!root->lchild) {
        root->lchild = pre;
        root->ltag = THREAD;
    }
    if (pre && !pre->rchild) {
        pre->rchild = root;
        pre->rtag = THREAD;
    }
    pre = root;
    return ;
}

void buildThreadTree(Tree *tree) {
    if (!tree) return ;
    buildThreadNode(tree->root);
    return ;
}
```



## 七、遍历后序线索化二叉树

由于后序线索化二叉树是无法访问到父节点的，所以需要使用栈，故而基本不用后序线索化二叉树。