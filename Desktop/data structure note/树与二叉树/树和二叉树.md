# 树和二叉树

## 一、树的一些性质(更多的复习离散数学)

1. 每棵非空树有且仅有一个根结点。

2. 根结点没有父结点，叶子结点没有孩子结点。

3. 父亲结点可以有多个孩子结点，除了根结点外，其余的结点有且仅有一个父结点。

4. 结点及其下面所有的结点并称为以该结点为根的子树。

5. 结点拥有的子树个数称为结点的度。

6. 在树上，从一个结点出发可以访问到其余的结点，并且一个结点到另一个结点的路径有且仅有一条。



## 二、二叉树

### 1.二叉树的5种基本形态

二叉树的每个结点最多只有两个孩子结点。因此二叉树有5种基本形态：

(1)空二叉树(树为空没有结点)； (2)只有根结点的二叉树； (3)只有左子树的二叉树； (4)只有右子树的二叉树； (5)左右子树都有的二叉树。

### 2.二叉树的性质

1. 二叉树的第i层最多有$2^{i-1}$个结点。
2. 深度为k的二叉树最多有$2^k-1$个结点。
3. 任意一棵二叉树上，其叶子结点个数$n_0$比度为2的结点数$n_2$多1。

### 3.满二叉树

如果一棵二叉树深度为k且有$2^k-1$个结点，那么称该二叉树为满二叉树，在此深度上不能再添加结点。

### 4.完全二叉树

如果一棵二叉树深度为k，**从第1层到第k-1层该树是满二叉树，第k层的节点都集中在左边，那么我们称该二叉树为完全二叉树**。

> 完全二叉树因其结构特性具有很高的效率，经常被用在算法的优化里。

### 5.二叉树的广义表表示形式

我们可以用广义表来表示二叉树，形式为 a(b,c)，表示根节点 a 的左孩子节点为 b，右孩子节点为 c，中间用一个逗号隔开。

如果左右孩子节点不为空，则用以上形式来替换；如果节点为空，则不填任何字符。

以下是几种常见的格式： 

+ a：表示根节点为 a，左右孩子节点均为空；
+  a(b)：表示根节点为 a，左孩子节点为 b，右孩子节点为空； 
+ a(,c)：表示根节点为 a，左孩子节点为空，右孩子节点为 c； 
+ a(b,c)：表示根节点为 a，左孩子节点为 b，右孩子节点为 c。

输出二叉树的广义表形式的伪代码：

```
输出节点存储的值；
如果左孩子不为空：
    输出 "("；
    递归输出左子树；
    如果右孩子为空：
        输出 ")"。
如果右孩子不为空：
    如果左孩子为空：
        输出 "("。
    输出 “,”；
    递归输出右子树；
    输出 ")"。
```

> ==将二叉树以广义表形式输出和将广义表转换为二叉树实际上都是**解决具有完全包含关系的问题**，可以使用栈(自定义，后者系统的(即递归))。==

### 6.将广义表创建成二叉树

将广义表创建成二叉树，可以借助栈来实现，利用栈先进后出的特点，先将根节点压入栈中，如果左孩子节点不为空，则将其作为栈顶节点（即其父亲节点）的左孩子节点，并压入栈中，递归左子树，处理完之后左孩子节点出栈；如果右孩子不为空，则将其作为栈顶节点（即其父亲节点）的右孩子节点，并压入栈中，递归右子树，处理完之后右孩子节点出栈。

在转换过程中，我们可以这么理解，**左括号表示进入二叉树的下一层，右括号表示返回上一层，逗号表示从左子树转到右子树。**

```
设置一个标记变量 k，初始为 -1；
设置一个标记节点 p；
循环遍历存储广义表的字符串 str：
    如果 str[i] 是左括号：
        则设置 k 为 0；
        把 p 压入栈中。
    否则如果 str[i] 是逗号：
        则设置 k 为 1。
    否则如果 str[i] 是右括号：
        则栈顶元素出栈。
    否则如果 str[i] 是一个字母，用节点 temp 来存储：
        如果 k 为 -1：
            则把 temp 作为根节点并压入栈中。
        如果 k 为 0：
            如果此时栈顶节点是 p，则先出栈；
            然后将 temp 作为栈顶节点的左孩子；
            再把 temp 压入栈中。
        如果 k 为 1：
            栈顶元素出栈；
            将 temp 作为栈顶节点的右孩子；
            再把 temp 压入栈中。
```

