# 表达式求值的多种解法

表达式求值可以使用栈来解决，并且，我们可以发现表达式求值具有完全包含关系，因此，具有完全包含关系的一种数据结构——树，也是可以用来解决表达式求职问题的;

由于我们定义的栈与系统栈是一样的，所以我们也可以使用系统栈来解决（使用递归）。

## 一、递归求解表达式求值问题

表达式求值问题求解过程中最重要的就是运算符优先级的问题，所以要着重解决运算符优先级。

此外对于想表达式求值这种显式完全包含关系的问题，使用递归时通常是要加上范围的，通常是一个区间。

在使用递归求解表达式求值问题的时候，我们可以将表达式转换为二叉树的形式，优先级越低的节点越接近根节点，一棵表达式树的根节点就是优先级最低的运算符，那么表达式求值就可以根据其完全包含关系的性质，计算出子表达式的值，之后计算原表达式的值，就这样可以递归求解。

> 一个启发：具备完全包含关系的问题，可以考虑使用栈、递归，以及使用二叉树作为思路的启发。

```c++
int calc(const char *str, int l,int r) {
    //prior实际上表示的是最小的优先级，初始化时为了方便实际的操作，我们会尽量将其优先级设置高一些
    //temp表示的是基准优先级，由于括号是具备改变优先级的作用的，所以需要使用temp来处理遇到括号时括号内部的运算符的优先级，这些优先级以括号的基准优先级为基础，遇到左括号+100,遇到右括号-100,这样可以较好地区分括号内与括号外
    // pos是比较明显的，其作用是用来保存当前优先级最低(从前往后数)的一个运算符号的位置
    int prior = 10000 - 1, temp = 0, pos = -1;
    // 这里for循环的作用是找到l-r下标范围内的优先级最低的运算符的位置
    for (int i = l; i <= r; i++) {
        // cur_prior表示的是当前运算符的优先级，在遇到括号时就会自动覆盖为新的基准优先级，之后再还原，遇到其他运算符号，则计算出这个运算符号在当前基准优先级下的优先级，并且更新当前优先级
        // cur_prior初始化时一定要比prior大一些，为了处理当前区域没有运算符，只是一个纯数字的情况
        int cur_prior = 10000;
        switch (str[i]) {
            case '(': temp += 100; break;
            case ')': temp -= 100; break;
            case '+' : 
            case '-' : cur_prior = temp + 1; break;
            case '*' : 
            case '/' : cur_prior = temp + 2; break;
            case '^' : cur_prior = temp + 3; break;
        }
        // 获得最小优先级以及其运算符的对应位置
        if (cur_prior <= prior) {
            prior = cur_prior;
            pos = i;
        }
    }
    //pos为-1的话表示当前的区域内是一个纯数字，那么就需要计算出这个纯数字，作为结果直接返回
    if (pos == -1) {
        int num = 0;
        for (int i = l; i <= r; i++) {
            if (str[i] < '0' || str[i] > '9') continue; 
            num = num * 10 + str[i] - '0';
        }
        return num;
    }
    // 以当前最小优先级的符号的位置为划分，递归计算子表达式的值
    int a = calc(str, l, pos - 1);
    int b = calc(str, pos + 1, r);
    // 根据当前运算符的符号计算结果
    switch (str[pos]) {
        case '+' : return a + b;
        case '-' : return a - b;
        case '*' : return a * b;
        case '/' : return a / b;
        case '^' : return (int) pow(a, b);
    }
    return 0;
}
```

