# 二分搜索简要分析

二分搜索适合用来在已经排好序的一组元素进行搜索，主要有4类二分搜索的题目类型：

## 一、精确搜索数据是否存在

这个就是简单的精确值二分搜索，其模板如下：

```c
int b_s() {
    int l = 1, r = m, mid; 
    while (l <= r) {
        mid = (l + r) >> 1;
        if (x[mid].val == y) return x[mid].num;
        if (x[mid].val < y) l = mid + 1; // 只要不相等，就不能包括
        else r = mid - 1;
    }
    return 0;
}
```



## 二、搜索第一个满足某种性质的数据

**搜索第一个满足某种性质的数据，这就是一种“000011111”类型的二分搜索题，由于其寻找元素是第一个满足性质的，==首先，中点位置是下取整的，这是为了保证第一性，其次，中点位置满足不一定第一个的条件时，右边界只能是跳到中点，这是为了防止跳过第一元素。==**

```c++
int b_s() {
    int l = 1, r = m, mid;
    while (l < r) {
        mid = (l + r) >> 1;
        if (x[mid].val < y) l = mid + 1;
        else r = mid; // 要找的是第一个满足某种性质的数据，那么这个数据一定要r=mid，第一个数据要防止下溢
    }
    return x[l].ind;
}
```



## 三、搜索最后一个满足某种性质的数据

**搜索最后一个满足某种性质的数据，是“1111100000”类型的搜索题，==中点位置是上取整的，要保证是最后一个满足某种性质的数据，==要防止的是数据的上移，左边界不能跳过最后一个元素。**

```c++
int b_s() {
    int l = 1, r = m, mid;
    while (l < r) {
        mid = (l + r + 1) >> 1; // 找最后一个满足性质的数据，要保证数据的最后性，需要上取整
        if (x[mid].val < y) l = mid; //要找最后一个满足某种性质的数据，左边界不可以超过最后一个满足性质的元素
        else r = mid - 1; 
    }
    return x[l].ind;
}
```



## 四、二分答案

**许多会用到二分搜索的问题，往往是对答案范围进行二分，这是==二分搜索的一大主要解体思路。对答案进行二分，通过判断是否满足题目要求条件来进行解答==。**

**很多可以大致可以归结为搜索类型的题目，但是又不适合使用深度与广度优先搜索的，就尝试使用二分搜索，对答案的范围进行二分来进行求解。**