# HZOJ 590 数塔狂想曲 题解

## 题目描述

 相信大家都学过树塔问题，题目很简单求最大化一个三角形数塔从上往下走的路径和。走的规则是：（i，j） 号点只能走向 （i+1，j） 或者 （i+1，j+1）。如下图是一个数塔，映射到该数塔上行走的规则为：从左上角的点开始，向下走或向右下走直到最底层结束。

小 S 觉得这个问题 soeasy。于是他提高了点难度，他每次 ban 掉一个点（即规定哪个点不能经过），然后询问你不走该点的最大路径和。当然他上一个询问被 ban 掉的点过一个询问会恢复（即每次他在原图的基础上 ban 掉一个点，而不是永久化的修改）。



## 分析

数塔问题是一道经典的动态规划问题，根据状态定义的不同，**一个表示自顶到当前位置的路径长度，另一个表示从底到当前位置的最大路径长度，解法分成两种，自顶向下与自底向上。**

本题的暴力解法就是没禁用一个位置就重新计算，但是由于我们无法给禁用标记，这种方法实际上是不可取的。

事实上，经过(i,j)的路径的最大长度为$down(i,j)+up(i,j)-mmap[i][j]$。这样根本不需要改变禁用位置的值。

此外，要判断禁止一个点之后的数塔最大值，就是判断这个点是否在最大值路径上，如果在最大值路径上，那么新的最大值就是原来的次大值。因此，需要维护最大值与次大值的下标。



## 代码

```c++
#include<iostream>
#include<cstdio>
using namespace std;
#define MAX_N 1000
#define MAX_M 500000

int n, m;
int num[MAX_N + 5][MAX_N + 5];
int up[MAX_N + 5][MAX_N + 5], down[MAX_N + 5][MAX_N + 5];
int mmax[MAX_N + 5], mmax_ind[MAX_N + 5], mmax2[MAX_N + 5];
int x, y;

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) scanf("%d", &num[i][j]);
    }
    //构造down表
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            down[i][j] = max(down[i - 1][j - 1], down[i - 1][j]) + num[i][j];
        }
    }
    //构造up表
    for (int i = n; i > 0; i--) {
        for (int j = 1; j <= i; j++) {
            up[i][j] = max(up[i + 1][j + 1], up[i + 1][j]) + num[i][j];
        }
    }
    // 计算各层的最大值与次大值下标
    for (int i = 2; i <= n; i++) {
        int ind1 = 0, ind1_max = 0, ind2_max = 0;
        for (int j = 1; j <= i; j++) {
            // t表示过当前位置的路径的最大值，找每一层的最大值
            int t = down[i][j] + up[i][j] - num[i][j];
            if (t > ind1_max) {
                ind1_max = t;
                ind1 = j;
            }
        }
        for (int j = 1; j <= i; j++) {
            // t表示过当前位置的路径的最大值，这里准备来找每一层的次大值
            int t = down[i][j] + up[i][j] - num[i][j];
            if (t > ind2_max && j != ind1) {
                ind2_max = t;
            }
        }
        mmax[i] = ind1_max;
        mmax_ind[i] = ind1;
        mmax2[i] = ind2_max;
    }
    while (m--) {
        scanf("%d%d", &x, &y);
        // 禁用第一个元素，那么就没有路径
        if (x == 1 && y == 1) {
            printf("-1\n");
            continue;
        }
        // 如果替换掉的是最大值的所在路径，那么新的最大值就是原来的次大值
        // 否则最大值还是原来的最大值
        if (mmax_ind[x] == y) {
            printf("%d\n", mmax2[x]);
        } else {
            printf("%d\n", mmax[x]);
        }
    }
    return 0;
}
```

