# HZOJ 44 最长上升子序列 题解

## 题目描述

有一个数字序列，求其中最长严格上升子序列的长度。



## 分析

这是一眼就可以看出来是使用动态规划的问题。

定义状态$f(i)$为以下标为$i$位置结尾的的最长严格上升子序列的长度，以下标为$i$位置数字结尾的最长严格上升子序列的前一个数字在下标$0-(i-1)$之间，我们需要遍历一遍，当然这样的时间复杂度为$O(n^2)$，此时的状态转移方程为：
$$
f(n)=\max_{i=0，num[n]>num[i]}^{n-1}(f(i))+1
$$


## 代码

### 方法一：

```c++
#include<iostream>
using namespace std;
#define MAX_N 1000000

int n, mmax;
int num[MAX_N + 5];
int len[MAX_N + 5];

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) cin >> num[i];
    for (int i = 0; i < n; i++) len[i] = 1;
    for (int i = 1; i < n; i++) {
        int data = 0;
        for (int j = 0; j < i; j++) {
            if (num[i] > num[j]) data = max(data, len[j]);
        }
        len[i] = data + 1;
        mmax = max(mmax, len[i]);
    }
    cout << mmax << endl;
    return 0;
}
```



## 方法二：

此处在状态转移的过程中进行优化，**这种优化是==根据题目的特点决定的，但是也是有规律和某些题型的优化方法，我们可能会用到例如堆，单调队列，单调栈等数据结构来维护这些信息，加速查找。==**

在这里，每次都要求查找前面最后一个数字小于当前位置数字的子序列的最大长度，这段查询需要$O(N)$的时间，但是我们可以维护一个堆，该数组记录指定长度的子序列的最小的最后元素，这样可以节省大量的查询时间，单次查询时间实际上优化到了$O(1)$。

```c++
#include<iostream>
using namespace std;
#define MAX_N 1000000

int n, mmax;
int num[MAX_N + 5];
int dp[MAX_N + 5], ans;
int len[MAX_N + 5];

int bs(int *arr, int l, int r, int x) {
    if (l == r) return l;
    int mid = (l + r) >> 1;
    if (arr[mid] < x) return bs(arr, mid + 1, r, x);
    return bs(arr, l, mid, x);
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> num[i];
    for (int i = 1; i <= n; i++) dp[i] = 1, len[i] = n + 1;
    len[++ans] = num[1];
    for (int i = 2; i <= n; i++) {
        dp[i] = bs(len, 1, ans + 1, num[i]);
        len[dp[i]] = num[i];
        ans = max(ans, dp[i]);
    }
    cout << ans << endl;
    return 0;
}
```

