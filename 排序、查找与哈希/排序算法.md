# 排序算法

排序算法就是给定一个n个元素的线性表$(a_0,a_1,...,a_{n-1})$，排序算法返回这个序列重新排列的结果$(A_0,A_1,...,A_{n-1})$，满足$A_0 \leq A_1 \leq ...\leq A_{n-1}$，这里的小于等于符号也可以换成其他符号(大于等于之类的)。

## 一、排序算法的分类

**稳定排序：**对于一个排序算法，若任意两个元素$a_i$和$a_j$在排序之前的线性表中满足条件$i<j$且$a_i = a_j$，在排序之后$a_i$仍在$a_j$之前，则称这个排序算法是稳定的。

**不稳定排序：**稳定排序的反情况。

此外，排序算法还分为**内部排序(在内存里面排序)**，**外部排序(不一定全部加载到内存里进行排序)**。

> ==归并排序由于可以将大规模数据分为小规模数据，所以可以用于外部排序(当然内部排序也是可以的)。==

**外部排序最常用的算法是多路归并排序**，即将原文件分解成多个能够一次性装入内存的部分分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行归并排序。



## 二、稳定排序

三种稳定排序：插入排序，冒泡排序，归并排序。

### 1.插入排序

插入排序的基本思想：将线性表分为已排序的前半部分和待排序的后半部分，从待排序部分选出地一个元素，插入到已排序部分的对应位置中，直到全部记录都插入到已排序部分中。

插入排序每次插入的时间复杂度为$O(n)$,这个时间复杂度由查找时间和移动元素时间组成。因此，总体时间复杂度为$O(n^2)$。

> 虽说是插入排序，但是我们是从后往前进行比较和遍历、交换。

插入排序的实现代码如下：

```c++
void insert_sort(int *arr, int n) {
    for (int i = 1; i < n; i++) {
        //for循环和while循环中的一个通用代码优化技巧：将循环中的判断条件试着移入for或者while循环的判定条件中
        for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
            swap(&arr[j], &arr[j + 1]);
        }
    }
}
```



### 2.冒泡排序

冒泡排序是基于交换的排序算法，基于交换的排序，是指根据线性表中的元素关键字的比较结果来对换这两个元素在序列中的位置。（也是分成了排序区和待排序区）

冒泡排序的基本思想：若待排序线性表的长度为n，从前往后两两比较相邻元素的关键字，若$a_{i-1}>a_{i}$则交换它们，直到线性表比较完成。每趟交换以后最后一个元素一定是最大的，不再参与下一趟交换。即第i趟交换只需要比较到$a_{n-i}$即可。直到一趟比较中没有交换，算法结束。时间复杂度也是$O(n^2)$。

> 冒泡排序实际上有两种方向，但是为了方便起见，我们使用从前到后的交换方向。
>
> 此外，冒泡排序还有一个优化：若当前一趟没有发生交换，那么说明已经有序了

冒泡排序的实现代码如下：

```c++
void bubble_sort(int *arr, int n) {
    // 这里的i的一种理解可以是当前已排序区的元素的个数，每次循环已排序区的元素就会增加一个
    for (int i = 0; i < n; i++) {
        int swapped = 0;
        // 而这里的j就是待排序区的大小
        for (int j = 0; j < n - i; j++) {
            if (arr[j] <= arr[j + 1]) continue;
            swapped = 1;
            swap(&arr[j], &arr[j + 1]);
        }	
        //冒泡排序的一个优化，若当前一趟没有发生交换，那么说明已经有序了
        if (!swapped) break;
    }
}
```



### 3.归并排序

> 归并排序的易错点：
>
> (1)归并时两个有序线性表的合并，两个区间的元素的选择及条件
>
>  (2)拷贝排序好的部分，注意拷贝的一定要有==`sizeof(typename) * size`==,一定要注意`sizeof(typename)`，**==因为`memcpy()，memset()`这类内存操作函数是以字节为单位进行的！！！==**

**归并的含义是将两个有序的线性表组合成一个新的有序线性表。**

对于归并排序，若当前要排序的区间为$a_0,..a_{n-1}$，那么首先让$a_0,...a_{\frac{n-1}{2}}$和$a_{\frac{n-1}{2}+1},...a_{n-1}$这两个区间内的元素有序，再将这两个区间合并为一个更大的有序区间，知道整个线性表都被排序完成。==由此可见，归并排序是一个可以分治(具备完全包含关系)的问题，而我们通常是使用递归来实现归并排序。==

归并排序一共需要$O(\log{n})$层归并操作，每层归并操作的时间复杂度为$O(n)$，因此总体的时间复杂度为$O(n\log{n})$。

 **归并排序是具有完全包含关系的问题，因此，我们可以使用分治法来分解其为更小的子问题，归并，然后再拷贝回去。==分解，归并，拷贝这是归并排序的3个核心操作。==**

> 正常所说的归并排序是2路归并排序，但是实际上我们还有k路归并排序。
>
> ==**由于归并排序是可以将大规模数据分解为较小规模数据，所以归并排序可以处理大规模数据，不必将所有数据读入内存，因而可以进行外部排序**，而且在合并的时候我们实际上只需要移动指向数据区域的首指针(到当前区域末尾为止)来执行合并的操作，这是很简单的。==

归并排序的实现代码如下：

```c++
void merge(int *arr, int l, int r) {
    int temp[r - l + 1], mid = (l + r) >> 1;
    int p1 = l, p2 = mid + 1, i = 0;
    //当两个区间内还有元素没有处理完时，我们需要继续处理
    while (p1 <= mid || p2 <= r) {
        //左边的元素会被选择首先要求左边元素没有用完，此时还有的两种情况：
        //（1）右边部分已经遍历完毕
        //（2）左边的对应位置元素小于右边对应位置的元素
        // 一定要首先保证当前部分的元素没有处理完！！！否则会导致越界使用元素！！！
        if (p1 <= mid && (p2 > r || arr[p1] < arr[p2])) temp[i++] = arr[p1++]; 
        else temp[i++] = arr[p2++];
    }
    memcpy(arr + l, temp, sizeof(int) * (r - l + 1));
}

void merge_sort(int *arr, int l, int r) {
    if (l == r) return ;
    int mid = (l + r) >> 1;
    merge_sort(arr, l, mid);
    merge_sort(arr, mid + 1, r);
    merge(arr, l, r);
}
```

> **==一定要首先保证当前部分的元素没有处理完`x <= mid`！！！否则会导致越界使用元素引发错误！！！==**



## 三、不稳定排序

四种不稳定排序：选择排序，快速排序，堆排序，希尔排序(不学)。

### 1.选择排序

选择排序的基本思想：每趟从线性表的待排序区域选取关键字最小的元素，将其放在已排序区域的最后，选择排序的时间复杂度是$O(n^2)$。

选择排序的实现代码如下：

```c++
void select_sort(int *arr, int n) {
    for (int i = 0; i < n - 1; i++) {
        //一个优化，我们只需要记住当前找到的最小值的下标就可以了
        // 一旦找到更小值的下标，就更新下标就可以了
        int ind = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[ind]) ind = j;
        }
        swap(arr[i], arr[ind]);
    }
}
```



### 2.快速排序

快速排序的基本思想：每次从待排序区间选取一个元素（一般选取第一个，但是实际中是随机选的）作为基准记录，所有比基准记录小的元素都在基准记录的左边，而所有比基准记录大的元素都在基准记录的右边。之后分别对基准记录的左边和右边两个区间进行快速排序，直至将整个线性表排序完成。

**快速排序的实际过程：**

**将第一个元素和我们选择的枢纽元素进行交换，将枢纽元素取出，那么就相当于线性表中空出一个位置。**

**然后确定左右操作的边界，先从左往右找地一个小于此枢纽的数字，将此数字放入枢纽空出的位置，左边界自增，其实不增加也行，增加了就可以省一步操作，右边也空出了给枢纽的一个位置，==每次查找后空出来的位置千万不能变下标！！！变的是填入数字的位置的下标！！！==接着，从此位置开始从左向右寻找第一个大于枢纽的元素，再将此元素放入哦那个这的位置，此位置自减。如此循环至左右边界统一。**

==**在快速排序的过程中，一定要注意左边界小于右边界的这个条件在每一步操作中都要写，因为快速排序在任何一步操作的过程中都可能是极端情况。这样的操作有：两侧寻找小于、大于枢纽的元素，将找到的元素放入空着的枢纽位置，都是需要判断走边界是否小于右边界。因为每一步操作都可能造成左边界与右边界重合的情况。**==

 快速排序的时间复杂度不是稳定的，可以证明快速排序的平均时间复杂度为$O(n\log{n})$，最坏情况为 $O(n^2)$ ，可以通过随机选择基准记录来尽可能避免最坏情况的出现。

快速排序的代码如下：

```c++
void quick_sort(int *arr, int l, int r) {
    // 快排的第一个易错点：因为中间的枢纽可能会导致一侧的左右边界交错
    if (l >= r) return ;
    //一般将第一个数作为枢纽，如果使用随机的一个枢纽，那么通常是需要和地一个数字交换，下面的操作就一样了。
    int x = l, y = r, z = arr[l];
    while (x < y) {
        // 从右向左寻找小于枢纽的数，一定要保证x < y,因为在快速排序中不论是从右向左，还是从左向右的查找都可能会是一个完全小于或者完全大于枢纽的特殊情况
        while (x < y && arr[y] >= z) y--;
        //为了应对右侧都是比枢纽大的情况，一定要保证x<y,两者交换，虽说如此，只是将小的数放在枢纽现在的位置上，因为枢纽只需要最后放在x==y的位置就可以了
        
        // 由于现在的arr[y]现在是空的，所以y是暂时不能变化的！！！一旦变化了就会造成数据出错！！！
        if (x < y) arr[x++] = arr[y];
        while (x < y && arr[x] <= z) x++;
        if (x < y) arr[y--] = arr[x];
    }
    arr[x] = z;
    quick_sort(arr, l, x);
    quick_sort(arr, y + 1, r);
}
```





## 四、关于排序算法的思考

### 1.插入排序、冒泡排序的操作区域与比较次数

在编写插入排序、冒泡排序的时候，需要注意操作区域，然后根据比较、交换、移动的方向来确定在循环中的范围。

在插入和冒泡排序中，由于会频繁使用交换的操作，一般来说我们会将循环的范围比操作的区域的大小小1,这是为了方便比较与交换。

