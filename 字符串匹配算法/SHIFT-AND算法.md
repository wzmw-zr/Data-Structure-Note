# SHIFT-AND算法

## 一、SHIFT-AND算法原理

**SHIFT-AND算法根据字符在模式串中出现的位置对字符进行二进制编码(将模式串中的字符在模式串中的位置记录下来，当前位置是这个字符，记为1,否则记为0)**。在完成了这个预处理之后执行匹配。

事实上，**SHIFT-AND算法是$NFA$(非确定性有穷自动机)本质思想的一种简版实现，==是一种bitap算法，但是仅当模式串的长度小于当前机器的机器字长度时有效==。**

在进行匹配时，使用数字P来记录匹配状态，初始化为0。**匹配过程分为两部分：状态转移、状态判断。**

**状态转移方程：**
$$
P=((P << 1)|1)\; \& \; code[str[i]]
$$
**状态判断：**
$$
P \; \&(1 <<(n-1)) \ne 0 \;(or\; =1)
$$

> ==状态P中第$i$位为1,表示前$i$位字符匹配成功; 当P中第n位字符为1,意味着匹配成功。==
>
> 在状态转移方程中P在移位之后或上1是为了保证随时都可以接受新的第一位字符匹配，保证匹配能够正常进行。



## 二、SHIFT-AND算法分析与实现

SHIFT-AND算法在预处理阶段的时空复杂度是$O(m+|\sum|)$,$m$表示模式串长度，$|\sum|$表示字符集大小。搜索阶段的时间复杂度是$O(n)$。

在预处理阶段对字符进行编码的时候，也需要注意这里字符也是会重复出现的，所以在编码阶段也是采用哈希的思想来进行。

代码如下：

```c++
int shift_and(char *s, char *t) {
    int code[128] = {0};
    int len = 0;
    // 字符编码，len表示字符出现的位置，在编码时对1左移len位再与上之前的编码
    for (len = 0; t[len]; len++) {
        code[t[len]] |= (1 << len);
    }
    // shift-and算法的NFA本质，p是NFA的初始状态，初值为0
    int p = 0;
    for (int i = 0; s[i]; i++) {
        // 状态转移
        p = (p << 1 | 1) & code[s[i]];
        // 状态判断，1左移（len-1）位后第len位为1,如果此时p与之相与不为0,意味着匹配成功，此时的i是匹配字符串的最后一位， i - len + 1为实际开始匹配的地方。
        if (p & (1 << (len - 1))) return i - len + 1;
    }
    return -1;
}
```






## 三、SHIFT-AND算法的用途与思考

SHIFT-AND算法也都不需要回溯操作，所以也适合流式数据的处理。

> 到了这里，从$KMP$算法的$DFA$思想和$SHIFT-AND$算法的$NFA$思想，这就涉及到自动机思想，而自动机思想是在一个状态根据输入转移到一个或者多个状态，与之前所处的状态无关，所以自动机思想适合用来处理流式数据。
>
> 而自动机思想在字符串匹配中的体现与本质就是：每次自动机获得一个字符作为输入，转移到另一个状态。

SHIFT-AND算法可以用来进行真正意义上的模式匹配(如简单的正则表达式)。