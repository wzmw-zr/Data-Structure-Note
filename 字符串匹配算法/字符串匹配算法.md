# 字符串匹配算法

**字符串匹配问题的定义：在母串S中查找模式串T是否存在。**

常见的解决这个问题的算法有BF(Brute force)算法，$KMP$算法，BM算法(自学)等。

下面是BF算法与KMP的时空复杂度比较。

| 算法      | 时间复杂度 | 空间复杂度 |
| --------- | ---------- | ---------- |
| BF算法    | $O(n*m)$   | $O(1)$     |
| $KMP$算法 | $O(n+m)$   | $O(m)$     |

## 一、BF(Brute Force)算法

BF算法是朴素的字符串匹配算法，算法的流程如下：

```c++
1. 母串 S 的第一个字符和模式串 T 的第一个字符进行比较；
2. 如果相等，则继续比较下一个字符是否相等；
3. 如果不相等，则选择母串 S 的第二个字符和模式串 T 第一个字符进行比较
4. 重复步骤 2 和 3，直至在母串 S 中匹配到模式串 T 或者枚举到母串末尾。
```

由于BF算法嵌套了两层循环，所以时间复杂度为$O(n*m)$。

> 关于暴力算法可以优化的方向：
>
> ==在模式串与母串匹配的过程中，经常会有失配的情况，此时我们可以直观的发现，**失配之前的部分，模式串和母串是完全一样的**。==暴力算法没有考虑到使用这种性质，每次又都一个一个向后移动进行匹配比较，实际上，我们可以使用这个性质，利用模式串和母串这相同部分，来对算法进行优化，**因为这相同的部分中的最长相同前缀、后缀是可以利用的。**。



## 二、$KMP$算法

$KMP$算法的基本思想：

记$len_s$是字符串$s$的长度，$S_a^{b}$是字符串$S$从第$a$个字符到第$b$个字符的一个子串。

在下图中，$P_a$ 模式串$T$的一个前缀，$P_b$**是子串$S_0^i$的一个后缀(当然也是子串$T_0^i$的一个后缀)**，$P_a=P_b$。**并且==$P_a$和$P_b$是所有相等前缀和后缀中长度最大的。==**(换句话说，在失配的时候，我们可以通过这个相等的前缀和后缀来避免重复运算，如果这里没有相等的前缀和后缀，如果最终能够匹配的话，这部分和最终匹配的区间是绝对不会有交集的，这一点可以通过反证法来实现，而当前区间有相等前缀和后缀的话，就意味着这个后缀作为模式串新的开头可能会获得匹配的结果。那么就说明我们不需要在失配的那个区间停留，直接进入下一个区间)。

> $KMP$算法的一个特点：我们实际上每次是拿母串中的一个字符到模式串中找位置，实际上在这个过程中，母串的指针是不会移动的，只是模式串的指针在跳，此外，母串的指针只会往前走，不会有回溯操作，所以我们在处理母串的时候，甚至只需要一个字符就可以完成对整个母串的匹配。
>
> 由于$KMP$算法无需存储全部的母串，所以，$KMP$算法可以用于流式数据(==所有适合流式数据的算法都适合大数据==)的处理。此时只有模式串的指针在跳动，当模式串的指针移动到最后，那么就代表匹配完成。
>
> $KMP$算法的本质思想就是$DFA$(确定性有穷状态机)，我们可以通过当前的状态，根据输入，跳转到后面的确定状态。

模式串$T$和母串$S$在位置$i+1$的时候匹配失败。在$KMP$算法中，利用了$P_a$和$P_b$相等的这一特点，下一步直接将下标为$len_{P_a}$的字符$T[len_{P_a}]$与$S[i+1]$进行比较**。==因为模式串$T$和母串$S$在位置$i+1$的时候匹配失败说明了$S_0^i=T_0^i$==，**又因为$P_a=P_b$，所以$P_a$也可以看成是串$S_0^i$的后缀，那么下一步就匹配就可以直接跳到$T[len_{P_a}]$与$S[i+1]$进行比较了。

![string match](/home/zr/Desktop/data structure note/string match.png)

那么，我们实际上只需要知道第$i$个位置上的$len_{P_a}$的值就能在匹配失败的时候进行下一次匹配，那么我们可以将这个值就记录在next数组里。通常为了方便，我们只需记录前缀最后一个字符的下标，即$next[i]=len_{P_a}-1$。

==**既然模式串$T$和母串$S$在位置$i+1$的时候匹配失败说明了$S_0^i=T_0^i$，那么这就意味着我们可以预处理模式串$T$**==，这就可以得到上面的next数组。

关于next数组中元素的确定：

(1)在next数组中==**，如果子串$T_0^i$有相同的前缀和后缀(最大的)，那么$next[i]$纪录的最长前缀里最后一个字符的下标位置**==     (**前缀和后缀不包括子串本身**)。

(2)如果不存在相同的前缀和后缀，则$next[i]=-1$ 。



next数组的计算思路如下：

假设我们已经计算出了$next[i-1]$的值，现在要求$next[i]$的值。思路就是从$T_0^{i-1}$的最长相等前缀和后缀开始，判断是否可以构成$next[i]$所需的最长相等前缀和后缀，不若不能，就不断的寻找$T_0^{i-1}$中次长的相等前缀和后缀来进行判断，直到能够构成$T_0^i$的最长相等前缀和后缀，或者没有相等前缀后缀，此时返回-1。具体的算法流程如下：

1. 比较$T[i]$和$T[next[i-1]+1]$的值;
2. 如果相等，则$next[i]=next[i-1]+1$;
3. 如果不相等，则继续比较$T[i]和T[next[next[i-1]]+1]$的值，这里可以将子串$T_0^{next[next[i-1]]}$看成是$T_0^{i-1}$的次长相等前缀和后缀。
4. 重复以上操作直至next的值为-1。



关于next数组的优化：

在$T[i]和T[next[i-1]+1]$的值相等的时候，是直接找到了最长前缀和后缀;

但是如果$T[i]\neq T[nex[i-1]+1]$的时候，很有可能在持续迭代的过程中一直会有$T[next[i-1]+1]=T[next[next[i-1]]+1]$，那么我们就可以直接操作$next[i]=next[next[i-1]]+1$,这样我们可以避免不必要的匹配，直接一步到位，在一开始比较$T[i],T[next[i-1]+1]$的时候，相等的话可以正常进行，不想等的话可以避免不必要的比较操作。

> $KMP$算法使用时，我们是要把整个母串给处理一遍的。



## 三、SUNDAY算法

SUNDAY算法的核心思想是找到"黄金对齐点位"：在失配的时候，我们将失配点之后的点作为对齐点，接下来我们的任务就是从模式串的尾部开始向前寻找与这个点相同的点，然后将这两个点位对齐，重新进行模式串的匹配。如此重复直到匹配成功或者没有匹配。

SUNDAY算法通常应用于像WORD文档里的文本查找，因为SUNDAY算法不需要处理整个文档的文本，而我们使用$KMP$算法的话是需要将整个文档作为母串进行处理的，而整个文档中是会有大量字符是不会在模式串中出现的，所以此时SUNDAY算法的时间复杂度将会被优化到$O(\frac{n}{m})$。

> 这就体现了算法的选型的重要性，我们需要根据算法的特性和需要解决的问题的本质性质来选择算法，并不是一定看时间复杂度，有时候，我们只需要它的最有时间复杂度足够优秀就行了。



## 四、SHIFT-AND算法

SHIFT-AND算法对信息做了一个新的预处理：

将模式串中的字符在模式串中的位置记录下来，当前位置是这个字符，记为1,否则记为0，相当于形成了一个的编码。

> 对于预处理的理解：将原本的信息转换为另一种形式的信息，在后续的使用中，我们更多的是使用转换后的信息。

SHIFT-AND算法是$NFA$(非确定性有穷自动机)本质思想的一种简版实现。

SHIFT-AND每次新进来一个字符，都会更新P，P的第几位为1,就代表着匹配成功了模式串的第几位。

SHIFT-AND算法的匹配的两步：状态转移，状态判断。

SHIFT-AND算法也都不需要回溯操作，所以也适合流式数据的处理。

> 到了这里，从$KMP$算法的$DFA$思想和$SHIFT-AND$算法的$NFA$思想，这就涉及到自动机思想，而自动机思想是在一个状态根据输入转移到一个或者多个状态，与之前所处的状态无关，所以自动机思想适合用来处理流式数据。
>
> 而自动机思想在字符串匹配中的体现与本质就是：每次自动机获得一个字符作为输入，转移到另一个状态。

SHIFT-AND算法可以用来进行真正意义上的模式匹配(如简单的正则表达式)。