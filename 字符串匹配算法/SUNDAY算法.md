# SUNDAY 算法

> SUNDAY算法是对BF算法的最直接优化。

## 一、算法原理

==**SUNDAY算法的核心思想是找到"黄金对齐点位"：**==

在失配时**将主串中本轮参加匹配的最末位字符的下一位字符作为对齐点**(==**这个下一位字符指的是现在母串中进行匹配的匹配起点加上模式串长度后的字符**==)。此时有两种情况：

1. 该**字符没有在模式串中出现**，则可以**直接跳过**，即**移动位数 = 模式串长度 + 1；**
2. 否则，其**移动位数 =** 模式串长度 - 该字符最右出现的位置(以0开始) = **模式串中该字符最右出现的位置到尾部的距离 + 1。**对齐之后再从头开始匹配。

![1](/home/zr/Desktop/data structure note/字符串匹配算法/1.png)



## 二、算法实现

实现==**SUNDAY算法，需要维护一个偏移量表，这个偏移量表应当包含模式串中的所有字符在失配后母串指针应当移动的位数。**==

考虑到模式串中会有字符重复出现，需要记录的是这个字符到模式串尾部距离最小的，由于需要处理重复字符以及没有出现的字符，最好**使用一个哈希表记录(多数是用简单的数组)，并且相同字符我们只需要记录离模式串尾部最近的那个**，所以一次遍历就可以完成，时空复杂度都为$O(n)$。

**易错点：**==在构建完offset数组之后，进行匹配时，母串的指针只会在失配时根据offset数组中对应数值移动，在for中不用对母串指针进行后处理！！！==

代码如下：

```c++
int sunday(char *s, char *t) {
    int len1 = strlen(s);
    int len2 = strlen(t);
    int offset[128];
    for (int i = 0; i < 128; i++) offset[i] = len2 + 1;
    for (int i = 0; i < len2; i++) offset[t[i]] = len2 - i;
    // 注意在构建完offset数组之后，进行匹配时，母串的指针只会在失配时根据offset数组中对应数值移动，在for中不用对母串指针进行后处理！！！
    for (int i = 0; i < len1 - len2 + 1;) {
        int flag = 1;
        for (int j = 0; j < len2; j++) {
            if (s[i + j] == t[j]) continue;
            i += offset[s[i + len2]];
            flag = 0;
            break;
        }
        if (flag) return i;
    }
    return -1;
}

```



## 三、SUNDAY算法的应用

SUNDAY算法通常应用于像WORD文档里的**文本查找，因为SUNDAY算法不需要处理整个文档的文本**，而我们使用$KMP$算法的话是需要将整个文档作为母串进行处理的，而整个文档中是会有大量字符是不会在模式串中出现的，所以此时SUNDAY算法的时间复杂度将会被优化到$O(\frac{n}{m})$。

> 这就体现了算法的选型的重要性，我们需要根据算法的特性和需要解决的问题的本质性质来选择算法，并不是一定看时间复杂度，有时候，我们只需要它的最有时间复杂度足够优秀就行了。

