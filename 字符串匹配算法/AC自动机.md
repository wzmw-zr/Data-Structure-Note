# AC 自动机(Aho–Corasick algorithm)

## 一、AC自动机原理

**AC自动机是用来解决多模式串匹配问题的，是一种将$Trie$树和$KMP$相结合的算法。**

==**$Trie$树的核心点是根据字符进行状态转移，$KMP$模式匹配的核心点是通过状态转移减少重复匹配。**==

> 所有字符串匹配算法都是对模式串先进行预处理。

使用AC自动机有以下三个过程：

（1）根据模式串集合建立Trie树

（2）建立fail指针(**等价匹配指针**，**功能类似于next数组**)。在这里根节点就相当于next数组中的-1。==fail指针(等价匹配指针)只会指向上层已经完成了fail指针的节点，绝对不会只想本层的节点，可以使用反证法，从匹配的长度上来证明。==

参考next数组建立的过程，确定next[i]时需要依赖于next[i-1]，同样的在这里确定当前节点的fail指针依赖于其父节点的fail指针，而**为了保证确定子节点fail指针时，父节点的fail指针已经确定，那么就使用==层序遍历来处理节点==。**

（3）处理母串

> 使用AC自动机，母串的指针也是不回溯的，所以AC自动机也适合用来处理流式数据。



## 二、AC自动机构建fail指针(等价匹配指针)的三种情况

### 1.当前节点有非空等价匹配节点，并且其中一个非空等价匹配节点能够获得子节点的等价匹配节点

举个例子，母串中含有"sher" 这个片段，模式串集合中有"she","her"这两个模式串，当"she"完成匹配之后，遇到'r'就会发生失配。"she"中的"e"的fail节点(等价匹配节点)就是"her"中的'e'节点。

如果采用暴力做法，那么就需要重新从'h开始向后匹配，而这段匹配实际上已经在"she"的匹配中做过了，那么==**所谓等价匹配的含义就是，在失配节点已经匹配的字符串中，包含着一条或者多条从根节点到与失配节点节点值相同的其他高层节点的一条匹配。**==在这里的体现就是匹配完了"she"实际上就已经完成了 "he" 的匹配，采用fail指针(等价匹配指针)可以避免暴力算法从'h'开始的重复匹配。

### 2.当前节点有等价匹配节点，但是一直找到空等价匹配节点，此时这个孩子节点的等价匹配节点为根节点

### 3.当前节点是根节点





## 三、AC自动机的结构定义

这里使用最基本的Trie树的节点定义，但是多了一个指向等价匹配节点的fail指针。

```c++
typedef struct Node {
    int flag;
    struct Node *next[BASE], *fail;
} Node;
```



## 四、AC自动机的结构操作

### 1.初始化AC自动机

```c++
Node *getNewNode() {
    Node *p = (Node *) calloc(sizeof(Node), 1);
    return p;
}
```



### 2.插入字符串构建Trie树

```c++
int insert(Node *root, const char *str) {
    int cnt = 0;
    Node *p = root;
    for (int i = 0; str[i]; i++) {
        if (!p->next[str[i] - BEGIN_LETTER]) p->next[str[i] - BEGIN_LETTER] = getNewNode(), cnt++;
        p = p->next[str[i] - BEGIN_LETTER];
    }
    p->flag = 1;
    return cnt;
}
```



### 3.构建fail指针(等价匹配指针)

构建fail指针的过程与构建next数组类似，确定next[i]的值需要依赖于next[i-1]的值，同样的，构建当前节点的fail指针需要依赖于其父节点的fail指针，因此，**在构建fail指针时，需要首先将其父节点层的节点的fail指针全都求出来，所以需要==使用队列来进行层次遍历==**。

当然根节点的fail指针指向NULL，这个就和next[0]=-1是一个道理。

同时第一层的节点的fail指针都是指向根节点的。

> 关于fail指针(等价匹配指针)的理解：**当前节点的fail指针指向的节点是当前节点的等价匹配节点，即，==当前节点被匹配，就等价于fail指针指向的节点有从根节点到这的一个匹配==。**
>
> **从这两个匹配的位置来看，一个在后一个在前，就相当于KMP中的最长相同前后缀，**虽然这个不是在同一个区间上的。

```c++
void build_ac(Node *root, int n) {
    // 使用队列进行层序遍历，以此来构建fail指针
    Queue *q = init_q(n + 10); 
    // 根节点的fail指针指向NULL，作用与next[0]=-1一样
    root->fail = NULL;
    push(q, root);
    while (!empty(q)) {
        // 获取当前节点，由于是队列中出来的，该节点的所有上层节点的fail指针(等价匹配指针)都已经处理好了，当然这个节点的fail指针也是已经处理好的，因为出队元素就是用来完成其子节点的fail指针的赋值的。
        // 这里的now_node就是KMP中成功匹配部分的最后一个节点
        Node *now_node = front(q);
        pop(q);
        for (int i = 0; i < BASE; i++) {
            // 如果当前节点的这个孩子节点是空的，那么就直接跳过
            if (!now_node->next[i]) continue;
            // 找到当前节点的等价匹配节点p，由于AC自动机中节点就代表了状态，所以这里以状态来理解，下面的一部分操作就可以理解为状态转移
            Node *p = now_node->fail;
            // 失配时的状态转移
            // 失配时的处理，退出失配循环的情况有两种：
            // （1）当前的等价匹配不为空
            // （2）等价匹配不为空时，这个等价匹配节点的没有相同的孩子节点
            while (p && p->next[i] == NULL) p = p->fail;
            // 根据退出时状态节点的情况确定孩子节点的等价匹配节点，
            //如果当前状态节点为空，说明这个孩子的等价匹配节点应该是根节点，因为此时原节点的等价匹配状态节点已经变成了NULL，而NULL的字节点就只有根节点。
            //否则状态节点的相应孩子节点就是当前节点的相应孩子节点的等价匹配节点(fail节点)
            if (!p) now_node->next[i]->fail = root;
            else now_node->next[i]->fail = p->next[i];
            // 孩子入栈
            push(q, now_node->next[i]);
        }
    }
}
```

由此看来，**构建fail指针的过程实际上也就是一个通过状态转移的来完成的过程，只是，==构建的是当前节点的字节点的fail指针(等价匹配指针)，而且每次计算一个fail指针就需要初始化一次初始状态节点，而这个状态节点初始值是当前节点的等价匹配节点==**，要确定是当前节点的一个非空子节点的fail指针(等价匹配指针)。

> 而且Trie树的树型结构也决定了我们计算fail指针是从父节点的fail指针来计算的。
>
> 而且正是==**由于树型结构的特性，实际实现时是通过当前节点的等价匹配节点来计算孩子的等价匹配节点。**==



### 4.字符串匹配

AC自动机进行匹配时，是以根节点作为初始状态，以母串的字符作为输入，进行状态转移的。

```c++
int match(Node *root, const char *str) {
    // p是自动机状态，初始化为根节点
    Node *p = root;
    int cnt = 0;
    for (int i = 0; str[i]; i++) {
        int ind = str[i]  - BEGIN_LETTER;
        // 失配处理，状态转换为等价匹配节点状态，退出条件为等价匹配节点状态为空或者一个等价匹配节点状态的孩子得到匹配
        while (p && p->next[ind] == NULL) p = p->fail;
        // 匹配处理，根据状态p的情况进行状态转移
        if (p == NULL) p = root;
        else p = p->next[ind];
        Node *q = p;
        // 终态处理：统计当前状态下等价匹配状态节点中达到终止状态的个数
        while (q) cnt += q->flag, q = q->fail;
    }
    return cnt;
}
```



