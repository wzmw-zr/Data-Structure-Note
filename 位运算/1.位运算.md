# 位运算

位运算就是基于整数的二进制表示进行的运算。由于计算机内部就是以二进制来存储数据，位运算是相当快的。

基本的位运算符有6种，与(`&`)，或(`|`)，异或(`^`)，取反(`~`)，左移(`<<`)，右移(`>>`)。

## 一、基本位运算符

### 1.与，或，异或

与(`&`)，或(`|`)，异或(`^`)是双目运算符，它们都是将两个整数作为二进制数，对二进制表示中的每一位逐一运算。

| 运算符 | 解释                           |
| ------ | ------------------------------ |
| `&`    | 只有两个对应位都为1时才为1     |
| `|`    | 只要两个对应位中有一个1时就为1 |
| `^`    | 只有两个对应位不同时才为1      |

异或运算的逆运算是其本身，也就是说两次异或同一个数最后结果不变，即`a^b^b=a`(即**两个相同数异或结果为0, 0和任何数异或结果都是那个数本身**)。

> Google老喜欢考一些位运算题目。。。



### 2.取反

取反是单目运算符，对一个数`num`的补码按位取反。

> 补码：在二进制表示下，正数和 0 的补码为其本身，负数的补码是将其对应正数按位取反后加一。



### 3.左移、右移

`num << i`表示将`num`的二进制表示向左移动i位所得的值。

`num >> i`表示将`num`的二进制表示向右移动i位所得的值。

移位运算中如果出现如下情况，则其行为未定义：

1. 右操作数（即移位数）为负值；
2. 右操作数大于等于左操作数的位数；

例如，对于 `int` 类型的变量 `a` ， `a<<-1` 和 `a<<32` 都是未定义的。

对于左移操作，需要确保移位后的结果能被原数的类型容纳，否则行为也是未定义的。[1](https://oi-wiki.org/math/bit/#fn:note1)对一个负数执行左移操作也未定义。

对于右移操作，右侧多余的位将会被舍弃，而左侧较为复杂：对于无符号数，会在左侧补 0；而对于有符号数，则会用最高位的数（其实就是符号位，非负数为 0，负数为 1）补齐。



> 位运算的复合赋值运算符`&=, |=, ^=, <<=, >>=`。



## 二、位运算的应用

1. 高效地进行某些运算，代替其他低效的方式。
2. **表示集合(状态压缩DP)**。
3. 题目本来就要求进行位运算(直白说的或者需要使用位运算性质的)。



## 三、位运算的使用例子

### 1.乘2的非负整数次幂

```c++
int mulPowerOfTwo(int n, int m) { return n << m; } // 计算n * (2 ^ m)
```

### 2.除以2的非负整数次幂

```c++
int divPowerOfTwo(int n, int m) { return n >> m; } // 计算n / (2 ^ m)
```

### 3.判断一个数是不是2的非负整数次幂

```c++
bool isPowerOfTwo(int n) { return n > 0 && (n & (n - 1) == 0); }
```

### 4.对2的非负整数次幂取模

```c++
int modPowerOfTwo(int x, int mod) { return x & (mod - 1); } // mod = 2 ^ m
```

### 5.取一个数二进制的某一位

```c++
int getBit(int a, int b) { return (a >> b) & 1; }
```

### 6.将一个数二进制的某一位设为0

``` c++
int unsetBit(int a, int b) { return a & ~(1 << b); }
```

### 7.将一个数二进制的某一位设为1

```c++
int setBit(int a, int b) { return a | (1 << b); }
```

### 8.将一个数二进制的某一位取反

```c++
int flapBit(int a, int b) { return a ^ (1 << b); }
```

### 9.确定一个数的最低位的1

```c++
int lowestOne(int a) { return a & (-a); }
```

### 10.消除一个数最低位的1

```c++
int eraseLastOne(int a) { return a &= (a - 1); }
```



## 四、位运算与集合

### 1.位运算表示集合

一个数的二进制表示可以看做是一个集合(0表示不在集合中，1表示在集合中)。对应的位运算也就可以看做是对集合进行的操作：

| 操作   | 集合表示     | 位运算语句 |
| ------ | ------------ | ---------- |
| 交集   | $a \cap b$   | `a & b`    |
| 并集   | $a \cup b$   | `a | b`    |
| 补集   | $\over{a}$   | `~a`       |
| 差集   | $a - b$      | `a & (~b)` |
| 对称差 | $a \oplus b$ | `a ^ b`    |

### 2.遍历某个集合的子集

```c++
// 遍历 u 的非空子集
for (int s = u; s; s = (s - 1) & u) {
    // s 是 u 的一个非空子集
}
```

用这种方法可以在$O(2^{popcount(u)})(popcount(u)表示u二进制中1的个数)$的时间复杂度内遍历$u$的子集，进而可以在$O(3^n)$的时间复杂度内遍历大小为$n$的集合的每个子集的子集(因为每个元素都有 不在大子集 / 只在大子集/ 同时在大小子集中 三种状态)。

**==如果需要操作的集合非常大，可以使用`bitset`==**。



## 五、内建函数

GCC中有一些用于位运算的内建函数，这些内建函数经过了编译器的高度优化，运行速度极快，有些甚至只需要一条指令。

1. `int __builtin_ffs(int x)`：返回x的二进制末尾最后一个1的位置，位置的编号从1开始(最低位编号为1)，当x为0时返回0。[`ffs = final first`]

2. `int __builtin_clz(unsigned int x)`: 返回x的二进制的前导0的个数，当x为0时，结果未定义[`clz = count lead zero`]。

   > 一个数 `n` 的二进制表示的位数可以使用 `32-__builtin_clz(n)` 表示。
   >
   > `31-__builtin_clz(n)` 就可以求出 `n` 以二为底的对数。

3. `int __builtin_ctz(unsigned int x)`:返回x的二进制末尾连续0的个数，当x为0时，结果未定义[`ctz = count tail zero`]。

4. `int __builtin_clrsb(int x)` ：当 的符号位为 时返回 的二进制的前导 的个数减一，否则返回 的二进制的前导 的个数减一。

5. `int __builtin_popcount(unsigned int x)`:返回x的二进制中1的个数。

6. `int __builtin_parity(unsigned int x)`:判断x的二进制中1的个数的奇偶性。

这些函数都可以在函数名末尾添加 `l` 或 `ll` （如 `__builtin_popcountll` ）来使参数类型变为 ( `unsigned` ) `long` 或 ( `unsigned` ) `long long` （返回值仍然是 `int` 类型）。



