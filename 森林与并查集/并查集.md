# 并查集

## 一、并查集的定义

**并查集(Merge-Find Set)，也被称为不相交集合(Disjoint Set**)，==并查集维护的是一堆集合(每个集合都有一个代表元素，即树根)而不是一个集合==也被认为是用于解决若干的不相交集合的如下几种操作的统称：

1. MAKE-SET(x):初始化操作，建立一个只包含元素x的集合
2. UNION(x,y):合并操作，将包含x和y的集合合并为一个新的集合
3. FIND-SET(x):查询操作，计算x所在的集合

**并查集通常既可以代表不相交集合的数据结构，也可以表示其对应的算法。**

> 并查集是一类解决存在连通性问题的数据结构。

> 并查集：
>
> 并：合并集合，是连通的操作
>
> 查：查询集合，是检查连通性的操作
>
> 四种并查集及优化：Quick-Find, Quick-Union, Weighted Quick-Union, Weighted Quick-Union with Path Compression



## 二、并查集的数据结构(结构定义)

**并查集在数据结构上是代表不相交的集合。**之前学过的树的数据结构实际上就是一个集合，**森林由互不相交的树组成，那么这就正好符合并查集的定义。**

==**通常我们会用有根树来表示集合，树中的每一个节点都对应集合的一个成员**==，每棵树表示一个集合。==**每个成员都有一条指向父节点的边，整个有根树通过这些指向父节点的边来维护**==。**每棵树的根就是这个集合的代表，并且这个代表的父节点是它自己**。(**这就是另一种理解：==节点代表集合，边代表关系==**)

这样，我们就可以将不相交的集合转化为一个森林，也叫不相交森林。我们正是通过不相交森林这个数据结构来实现并查集的初始化、合并和查询操作。

```c++
typedef struct UnionSet {
    // father数组保存集合代表， size数组表示集合元素个数
    int *father, *size;
    int n;
} UnionSet;
```





## 三、并查集的结构操作

### 1.并查集的初始化

**并查集的初始化操作是对每个元素都建立一个只包含该元素的集合，这意味着每个成员都是自身所在集合的代表**，所以我们只需要==将所有成员的父节点设为它自己==就好了。

```c++
UnionSet *init(int n) {
    UnionSet *s = (UnionSet *) malloc(sizeof(UnionSet));
    s->father = (int *) malloc(sizeof(int) * (n + 1));
    s->size = (int *) malloc(sizeof(int) * (n + 1));
    s->n = n;
    for (int i = 1; i <= n; i++) {
        s->father[i] = i;
        s->size[i] = 1;
    }
    return s;
}
```



### 2.并查集的查询操作

**并查集的查询是用来获知某一个节点所在具体的树的操作。**可以通过每个指向父节点的边回溯到节点所在有根树的根，也就是对应集合的代表元素。

并查集查询操作的算法流程如下：

```c++
1. 寻找当前节点的父节点。
2. 如果父节点是它本身，则该父节点为树的根节点，直接返回；否则返回步骤 1。
```

并查集的带有路径压缩的查询操作：

```c++
int find(UnionSet *u, int x) {
    // 在查找集合代表元素的过程中，不断将查询路径上的元素进行路径压缩
    // 路径压缩非常适合查询比较多的场合，当然普通情况下也能起到很好的优化效果
    return u->father[x] = (u->father[x] == x ? x : find(u, u->father[x]));
}
```



### 3.并查集的合并操作

并查集的合并操作是用来合并两个元素所在的集合。需要**首先求出两个元素所在集合的代表元素，也就是节点所在有根树的根节点**。接下来**将其中一个根节点的父亲设置为另一个根节点**，这样我们就把两棵有根树合并成一棵了。

并查集合并操作的算法流程如下：

```c++
1. 分别获得传入的两个节点所在的树的根节点。
2. 如果两个根节点相同说明它们在一棵树上，返回 false，结束合并操作。
3. 如果两个根节点不同，则将其中一个根节点的父指针指向另一个根节点，合并操作完成，返回 true。
```

并查集的带有按秩合并的合并操作：

```c++
int merge(UnionSet *u, int a, int b) {
    int fa = find(u, a), fb = find(u, b);
    if (fa == fb) return 0;
    // 将节点数量少的集合连接到节点多的集合上
    if (u->size[fa] > u->size[fb]) swap(fa, fb);
    // 更新集合的代表元素
    u->father[fa] = fb;
    // 更新集合的秩
    u->size[fb] += u->size[fa];
    return 1;
}
```



## 四、并查集的两种优化方法

**并查集的查询操作在最坏情况下的时间复杂度是$O(N)$，**其中$N$为总元素个数。**最坏情况发生时，每次合并对应到森林上都是一个点连到一条链的一端。可以看出，此时的森林相当于退化为一个链表。**在这种情况下，如果每次都查询链的最底端，也就是最远离根的位置的元素时，复杂度便是$O(N)$。

> 会造成并查集发生退化的两种情况：（1）节点多的树连接到节点少的树上（2）树深的连接到树低的树上

### 1.按秩合并

为了改善时间效率，可以通过启发式合并方法，**将包含较少节点的树接到包含较多节点的树根上，可以防止树退化为一条链**。这种方法称为——按秩合并。

并查集按秩合并的算法流程如下：

```c++
1. 利用一个数组保存每个节点的所在树的节点总数，即保存每个节点的秩。
2. 分别获得传入的两个节点所在的树的根节点。
3. 比较两个根节点是否相同，相同则返回 false，结束合并操作、
4. 若两个根节点的秩不同，比较他们的秩的大小。
5. 将秩较小的根节点的父指针指向秩较大的跟节点。
6. 更新合并后的根节点的秩，返回 true，结束合并操作。
```



### 2.路径压缩

另外，我们也可以通过路径压缩的方法来进一步减少均摊复杂度。**路径压缩优化也是为了避免树过长及过多的单链导致查找效率过低的操作。**

实际上，在**进行路径压缩优化时，只需要==在查找根节点时，将待查找节点的父指针指向它所在的树的根节点就可以了==。**

> ==**通常我们对于并查集的优化只是选用路径压缩，因为使用路径压缩性能基本上和路径压缩加按秩合并一样，而使用路径压缩还可以节省一倍的存储空间。**==



## 五、并查集的应用与思考

### 1.并查集的应用

**并查集是用来解决连通性问题的。**

**树与图的连通性体现在边上，边代表的是关系。可以将多个边所代表的关系通过连通性获得相应的关系**，边、连通性、关系是三个相关连的概念。

**两个点之间具有连通性，那么它们就处于同一棵树中**。那么连通操作实际上是树之间的连通，即集合之间的连通。

### 2.并查集的局限性

**并查集的合并操作是不可逆的，换句话说就是只合不分**，两个集合(树)合并之后就不会再分开来了。

**并查集只会维护集合和元素之间的关系，至于元素之间的直接关系(无法根据集合和元素的关系获得的)，比如节点之间直接相连的边，这种信息在并查集中是不会维护的。**而可以通过元素与集合之间的关系间接获得元素之间关系的那种是不算的。

